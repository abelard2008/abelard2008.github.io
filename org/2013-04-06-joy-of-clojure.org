#+STARTUP: showall indent
#+STARTUP: hidestars
#+OPTIONS:   H:2 num:nil toc:nil \n:nil ::t |:t -:t f:t *:t <:t

#+OPTIONS:   tex:t  d:nil todo:t pri:nil tags:not-in-toc

#+BEGIN_HTML
---
category: computer science and enginneering
layout: post
title: "Joy of Clojure"
tags: [Language, Clojure]
---
#+END_HTML

* 如何在repl中运行第10.2中的例子
-----------------------------

- 目录情况

#+BEGIN_SRC sh

[abelard@abelard src]$ tree

.
`-- joy
	|-- gui
	|   |-- DynaFrame.clj
	|   `-- socks.clj
#+END_SRC

- CLASSPATH现在并不包括DynaFrame.clj相关的目录


- 按照p213，在目录
#+BEGIN_SRC sh
	[abelard@abelard gui]$ pwd
	
	/study/clojure/joyofclojure/src/joy/gui
	
	[abelard@abelard gui]$ 
#+END_SRC
执行
#+BEGIN_SRC sh

	[abelard@abelard gui]$ lein repl
	nREPL server started on port 43985
	REPL-y 0.1.9
	Clojure 1.4.0
		Exit: Control+D or (exit) or (quit)
		Commands: (user/help)
		Docs: (doc function-name-here)
		(find-doc "part-of-name-here")
		Source: (source function-name-here)
			(user/sourcery function-name-here)
			Javadoc: (javadoc java-object-or-class-here)
		Examples from clojuredocs.org: [clojuredocs or cdoc]
				(user/clojuredocs name-here)
				(user/clojuredocs "ns-here" "name-here")
			user=> （compile 'joy.gui.DynaFrame)
#+END_SRC
得到如下错误：
#+BEGIN_SRC sh
	FileNotFoundException Could not locate joy/gui/DynaFrame__init.class or joy/gui/DynaFrame.clj on classpath:   clojure.lang.RT.load (RT.java:432)
#+END_SRC
解决办法：

1. 退出repl并执行如下命令
#+BEGIN_SRC sh
	[abelard@abelard gui]$ mkdir classes

	[abelard@abelard gui]$ export CLASSPATH=$CLASSPATH:/study/clojure/joyofclojure/src/joy/gui/classes:/study/clojure/joyofclojure/src/joy/gui/classes
#+END_SRC
而后，按书上的执行：
#+BEGIN_SRC sh
	user=> (compile 'joy.gui.DynaFrame)
	joy.gui.DynaFrame
	user=> (joy.gui.DynaFrame. "1st")
	UnsupportedOperationException joy.gui.DynaFrame/df-init
	not defined  joy.gui.DynaFrame.<init> (:-1)
#+END_SRC
得到了和书上一致的效果。

2. 可能出现的问题
如果不创建classes目录，得到如下错误
#+BEGIN_SRC sh
	CompilerException java.io.IOException: No such file or directory, compiling:(joy/gui/DynaFrame.clj:2) 
#+END_SRC
如果不将classes目录添加到CLASSPATH中，(joy.gui.DynaFrame "1st")将得到如下错误
#+BEGIN_SRC sh
	CompilerException java.lang.ClassNotFoundException: joy.gui.DynaFrame, compiling:(NO_SOURCE_PATH:1) 
#+END_SRC

* Macros
--------------

- 设置局部标识符方法
为了创建唯一的本地名字，Clojure提供了一个reader form。在一个使用语法引号(syntax-quote)括起来的form内，你能添加一个#号到非限定名(unqualified name)后，这样，Cojure将创建一个自动生成的标识符内，或说auto-gensym: 在名字上带有下划杠和唯一ID的标
识符。举例如下：
#+BEGIN_SRC sh

	user> (defmacro local-name []
		`(let [name# 50]
			(prn name#)))
		# 'user/local-name
	user> (macroexpand '(local-name))
		(let* [name__5179__auto__ 50] (clojure.core/prn name__5179__auto__))
	user> (local-name)
		50
		nil
    user> 
#+END_SRC
- ~'
在标识符前面添加 ~' 能达到相同的效果，但是不能保证在命名空间中唯一。举例如下：
#+BEGIN_SRC sh
	user> (defmacro local-name []
		`(let [~'int 50]
			(prn ~'int)))
    #'user/local-name
	user> (macroexpand '(local-name))
		(let* [int 50] (clojure.core/prn int))
			user> (macroexpand '(local-name))
				(let* [int 50] (clojure.core/prn int))
#+END_SRC
- 用宏来返回函数
先来看一个有let构造的函数：
#+BEGIN_SRC sh
	user> (let [x (fn [conf] (println "Starting supervisor" conf))] (defn mk-sup [& args] (apply x args)))
    #'user/mk-sup
#+END_SRC
从结果可以看出生成了一个mk-sup函数，当然就可以使用这个函数：
#+BEGIN_SRC sh
	user> (mk-sup 90)
	Starting supervisor 90
	nil
	user> (mk-sup)
	ArityException Wrong number of args (0) passed to:
	user$eval1287$x  clojure.lang.AFn.throwArity
	(AFn.java:437)
#+END_SRC	
需要解释的是，第二次没有使用参数调用时，提示输入参数错误，因为x所定义的匿名函数带有一个参数，并且这个参数的输入由调用mk-sup函数时提供。

- 另一种对let的使用
#+BEGIN_SRC sh
	user> ((let [x (fn [conf] (println "Starting supervisor" conf))] (defn mk-sup [& args] (apply x args))) 90)
		Starting supervisor 90
#+END_SRC
这样的定义是没有必要的，但是，对它的理解非常重要，因为它可以用来定义能够生产函数的宏：
#+BEGIN_SRC sh
	user> (defmacro product-func [name & body] `(let [x# (fn ~@body)] (defn ~name [& args#] (apply x# args#))))
	user> (product-func mk-sup [x &] (println "Starting	supervisor" x))
	user> (mk-sup 8)
	Starting supervisor 8
#+END_SRC
这里：(1) 定义一个宏 product-func (2) 用宏product-func来定义一个函数mk-sup (3) 调用函数。

这样的宏有什么意义呢？上面这样简单的定义除了知道可以这样使用let外，没有实质价值，但如果定义出下面这样的宏，就能明显体现其价值：
#+BEGIN_SRC java
	(defmacro defserverfn [name & body]
		`(let [exec-fn# (fn ~@body)]
			(defn ~name [& args#]
				(try-cause
					(apply exec-fn# args#)
						(catch InterruptedException e#
                           (throw e#))
					    (catch Throwable t#
							(log-error t# "Error on initialization of server " ~(str name))
								(halt-process! 13 "Error on initialization")
							)))))
#+END_SRC


