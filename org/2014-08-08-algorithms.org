#+STARTUP: showall indent
#+STARTUP: hidestars
#+OPTIONS:   H:2 num:nil toc:nil \n:nil ::t |:t -:t f:t *:t <:t

#+OPTIONS:   tex:t  d:nil todo:t pri:nil tags:not-in-toc
#+HTML_MATHJAX: align:"left" mathml:t path:"/MathJax/MathJax.js"

#+BEGIN_HTML
---
category: computer science and enginneering
layout: post
title: "Alogorithms"
description: "study some important algorithms"
tags: ["computing theory", alogorithms, "data structure"]
---
{% include JB/setup %}

<script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

#+END_HTML

* Hash
  Hash is a technique which addresses records provided with an
  identifier called primary key, or simply key.

  If two conditions hold, a hash table supports constant expected-time
  element access: the elements must be relatively evenly distributed
  among the slots, and the number of slots must vary in direct
  proportion to the number of elements.

 Given a good hashing function, presering constant-time access to
 elements requires keeping hash chains short. Keeping chains short
 without wasting space requires adjusting the number of slots as the
 number of elements changes.[fn:1]

[fn:1] The Design and Implementation of Dynamic Hashing for Sets and
Tables in Icon

  h(k) = k mod M, where M is prime.

* two types of popular hash functions
- division method

h(k) = k mod M, where M is prime

- multiplication method

h(k) = \lfloor m (k A mod 1) \rfloor [fn:1], where A is in the range 0 < A < 1, kA mod 1
is the fraction of the kA, in general, A is 0.6180339887 [fn:2]

An advantage of the multiplication method is that the value of m is not critical.
We typically choose it to be a power of 2 (m = 2^{p} for some integer p), since we
can then easily implement the function on most computers as follows. Suppose
that the word size of the machine is w bits and that k fits into a single word. We
restrict A to be a fraction of the form s=2^{w}, where s is an integer in the range
0 < s < 2^{w}. we first multiply k by the w-bit integer s = A * 2^{w}. The
result is a 2w-bit value r_{1} * 2^{w} + r_{0}, where r_{1} is the high-order
word of the product and r_{0} is the low-order word of the product. The desired p-bit hash
value consists of the p most significant bits of r_{0}. [fn:1]

why r_{1} * 2^{w} + r_{0} is equal to \lfloor M (kA mod 1) \rfloor, the reasoning steps is
as follows: 

\lfloor m ( kA mod 1) \rfloor \Leftrightarrow  \lfloor m \(\frac{k * s}{2^{w}}\)  mod 1 ] \rfloor \Leftrightarrow

\lfloor m (\(\frac{k * s}{2^{w}}\) mod 1) \rfloor \Leftrightarrow \lfloor m (\(\frac{ r_{1} * 2^{w}+ r_{0}}{2^{w}}\)
mod 1) \rfloor , where k * s can be equal to r_{1} * 2^{w} + r_{0}, and 

\(\frac{r_{0} * 2^{w} + r_{1}}{2^{w}}\) mod 1 \Leftrightarrow r_{1} + \(\frac{r_{0}}{2^{w}} \)

=> \(\frac{r_{1}}{2^{w}}\) \Leftrightarrow fraction of kA  

=> h(k) = \lfloor m \(\frac{r_{0}}{2^{w}}\) \rfloor = \lfloor 2^{p} \(\frac{r_{0}}{2^{w}}\) \rfloor

and because X * 2^{p} is X left shift p-bits and X / 2^{p} is right shift
p-bits, so that \lfloor 2^{p} \(\frac{r_{0}}{2^{w}}\) \rfloor \Leftrightarrow \lfloor \( \frac{r_{0}}{2^{w-p} \) \rfloor, which
is said that h(k) is p most significant bits of r_{0}.

[fn:1] ALGORITHMS INTRODUCTION TO THIRD EDITION THOMAS H.CHARLES E.RONALD L.CLIFFORD STEIN RIVEST
LEISERSON CORMEN 3rd Edition p264 
[fn:2] The Art of Computer Programming Vol3, Section 6.4

* Linear Hashing

* how to write a good hashcode()
In Effective Java, Item 9: Always override hashCode when you override
equals .

