#+STARTUP: showall indent
#+STARTUP: hidestars
#+OPTIONS:   H:2 num:nil toc:nil \n:nil ::t |:t -:t f:t *:t <:t

#+OPTIONS:   tex:t  d:nil todo:t pri:nil tags:not-in-toc

#+BEGIN_HTML
---
category: computer science and enginneering
layout: post
title: "Change Memory Allocation During the Early Stage of Linux Initalization for Crash  Data"
tags: ["Linux", "Linux Kernel", "Memory Management"]
---
#+END_HTML

* 内核初始化阶段分配内存
内核启动初期，并不能使用像kmallo之类的函数，因为这时候slab还没有开始工作，linux使用了一种称为early reserve的方式，以前使用成为BOOTMEM的分配方式，现在不用BOOTMEM了，但是很多函数还是沿用了老的名称。主要的有如下几个函数：

-  __alloc_memory_core_early(int nid, u64 size, u64 align,u64 goal,u64 limit)

-  alloc_bootmem(int size)
上面两个函数， *alloc_bootmem* 会调用第一个函数来完成， *__alloc_memory_core_early* 的goal为想要分配的起始物理地址，因此所有 *alloc_bootmem* 都会使用*_pa(MAX_DMA_ADDRESS))*生成一个固定的物理地址作
为goal，如果这个地址没有被分作其他用途，将得到一个goal开始的空间，否则，将在内存空间中找到一个符合size要求的内存块(并一个goal的地址)。如果分配成功，都会返回一个线性地址。如果失败，也不会影响什么。

- void __init reserve_early(u64 start, u64 end, char *name)

该函数没有返回值，所传入的起始和结束地址为物理地址，如果分配失败，就会宕机，因此它用于在启动最早期分配内存，并且确信分配肯定成功，如第一个使用者为*x86_64_start_reservations*函数(追查下去，该函数由汇编调用)。 使用该函数的主要为装载内核代码，BIOS相关、SMP相关等。

* 如何保证分配大块内存的起始地址不被分配函数修改
举例，在一个4G内linux系统中，为某个模块分配从1G位置开始的2G内存。希望1G的位置固定不变。

如果在init/main.c的start_kernel中，如*build_all_zonelists()*之后，插入上面的函数来分配空间，即使输入起始地址为1G(0x40000000)，最后返回的结果是起始地址发生了变化。

从kernel/early_res.c的*subtract_early_res*打印的所有启动早期分配的空间情况看，应该将要用于特定模块的大块内存尽早分配，以免被内核分配给其它功能模块。

但是考虑到灵活性，如只想给内核留下1G空间，剩下的内存都用于这个模块，因此需要获取内存大小的信息，linux在使用 *arch/x86/kernel/setup.c* 的 *setup_arch()* 函数中调用 *mtrr_bp_init()* 完成了内存大小的读取(具体通过e820功能模块)，并且将内存大小值存入 *range_sums* ，该变量定义为文件 *cleanup.c* 中的静态变量，为了文件外访问，改为全局变量，那样在 *setup_arch* 里就可以使用它来分析具体分配给这个特定模块的空间大小了，即在调用了 *mtrr_bp_init()* 之后，调用 *reserve_early* 函数：
#+BEGIN_SRC c
	reserve_early(0x40000000, 0xC0000000, "TP_SCST_RAID");
#+END_SRC
当然，分配出去的2G空间，在linux启动后，使用*free*命令就会发现，分出去的2G不会出现在空闲空间中。
