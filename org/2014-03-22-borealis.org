#+STARTUP: showall indent
#+STARTUP: hidestars
#+OPTIONS:   H:3 num:nil toc:nil \n:nil ::t |:t -:t f:t *:t <:t 
#+OPTIONS:   tex:t  d:nil todo:t pri:nil tags:not-in-toc
#+BEGIN_HTML
---
category: computer science and enginneering
layout: post
title: "borealis: install, run, understanding, change "
tags: [research, borealis, aurora]
---
{% include JB/setup %}

#+END_HTML

* server 和 client

HeaderServer has a member global catalog, a client application commit
a network diagram to HeaderServer, then HeaderServer determines which
elements goes to which nodes and deploys them using the deploy method.

DataPath类中，EnqueueThread用于接收来自客户端的数据，and every
Borealis node only has one input and one output implemented by
DataPath.

#+BEGIN_SRC C++ -n
void  DataPath::EnqueueThread::run()
{
    TCPAcceptor<DataHandler, ptr<DataHandler::DHArgs> >
                        acceptor(_data_loop,_data_add,args);

}
#+END_SRC
这里，TCPAcceptor的构造函数，最后调用NMSTL/net的
#+BEGIN_SRC C++ -n
    TCPAcceptor<DataHandler, ptr<DataHandler::DHArgs> >
                        acceptor(_data_loop,_data_add,args);
{
     if (f & acceptor) {
                setsockopt_struct(SOL_SOCKET, SO_REUSEADDR, int(1));
                if (bind(addr)) (ref:bind)
                    listen();
            } else {
                connect(addr); (ref:connect)
            }

}
#+END_SRC
很明显，line [[(bind)]] 创建服务器，line [[(connect)]] 创建客户端，在borealis
的服务器和客户端都是在这里建立的。

在AdminCatalog.cc中的QueryProcessor::add_xml_string(),当该string为head
标签时，则调用QueryProcessor::add_head_element(), 进而
#+BEGIN_SRC C++
 _head_client = new UpdateClient(InetAddress(endpoint), "BigGiantHead");
#+END_SRC
UpdateClient调用上面的line [[(connect)]] 将borealis节点自己称为
BigGiantHead的客户端，与其进行查询网络文件的交互，端口为35000。

在两个query位于不同的borealis节点时，upstream节点作为downstream节点的
publisher，因此在AdminCatolog.cc中的
QueryProcessor::subscribe_streams(),进而调用：
#+BEGIN_SRC C++
void  DataPath::add_output_path_client(CatalogSubscription sub)
{
 ptr<DataHandler>  dh(new DataHandler(_fast_dequeue_fwd._data_fwd_loop,
                                             TCPSocket(endpoint,
                                                       Socket::nonblocking),
                                             args));
//endpoint为downstream节点的ip地址
}
#+END_SRC
downstream节点也作为upstream节点的subscriber，其构建过程是从分析xml开始的，因此其调用堆栈为：

#+BEGIN_EXAMPLE
BasicComponent::endpoint_for()
BasicComponent::proxy_for()
BasicComponent::qp_for()
QueryProcessor::request_replicas()
QueryProcessor::local_add_subscriptions()
QueryProcessor::add_input_element()
QueryProcessor::add_xml_string()
#+END_EXAMPLE

在应用程序端，如test/simple/mytestdist，首先需要创建一个MedusaClient，
并设置用于接收结果的处理程序：
#+BEGIN_SRC C++
 _client = new MedusaClient(InetAddress());

 Status  status = _client->set_data_handler(
                                  InetAddress(Util::form_endpoint(MYTESTDIST_ENDPOINT,
                                                                  DEFAULT_MONITOR_PORT)),
                                  wrap(&outputHandler));

#+END_SRC
调用set_data_handler()后，进而调用NMSTL/net的Socket来将自己设置为服务
器端，端口为25000。

其次，为了提交和修改网络查询图，创建一个HeadClient，将自己设计成BigGiantHead的客户端，端口为
35000。

最后，为了流数据输入到某个Borealis节点，这个节点是查询网络中的首节点，
需要将自己创建为客户端：
#+BEGIN_SRC C++
if (!_client->set_data_path(MAX_BUFFER, Util::get_host_address("127.0.0.1"), 15000))
    {   ERROR << "Failed setting data path";
    }
    else
    {   DEBUG << "Set data path";

        _eventPacket = ptr<StreamEvent>(new StreamEvent(PACKET));
        _eventPacket->_inject = true;
    }

#+END_SRC
- python 版本 2.3
由于执行 demo/sigmod2005/cube/bot_src 目录下的setup过程中，python脚本
无法在FC12原始python版本下，有错误，下载python2.3的源码，编译
#+BEGIN_EXAMPLE
 cd /home/borealis/packages/Python-2.3
./configure --prefix=/home/borealis/builtTools/python/
make
make install
# 临时使用python，将原始/usr/bin/python重命名为python.bak
export PATH=$PATH:/home/borealis/builtTools/python/bin
#+END_EXAMPLE

* 运行demo中的cube
[[http://cubeengine.com/cube.php4][cube]] 是早期的第一人称射击游戏，现在的名称是[[http://assault.cubers.net/][AssaultCube]], 代码开源（被用
在布朗大学的 [[http://cs.brown.edu/courses/cs138/old/2006/][网络信息系统课程作业]] 中）。Borealis为了演示，修改了[[http://filebase.bots-united.com/index.php?act%3Dcategory&id%3D39][Cube
Bot version 0.2]] [fn:1]的源
代码，使得Borealis作为Cube引擎的一个服务器组件，在多人游戏中，游戏团队
的管理者可以注册连续查询服务，随时跟踪团队信息，以调整游戏策略。

无法知道Borealis所使用的cube源代码版本。Borealis在2005的SIGMOD上发表了
[[http://localhost:4000/reference/streamprocessing/sigmod05.demo.pdf][Distributed Operation in the Borealis Stream Processing Engine]], 并没有
描述是在borealis的哪个版本中运行的诸多细节，根据demo/sigmod2005/cube/
目录下的README说明，直接进行编译，无法通过，需要修改几处脚本文件和源代
码； 关于运行的指令也不是完全正确，需要做一些调整。

- 运行环境： 2.6.31.5-127.fc12.i686.PAE

- 要求安装的SDL包有：
#+BEGIN_EXAMPLE
SDL-devel-1.2.13-12.fc12.i686
SDL_mixer-1.2.8-13.fc12.i686
SDL-1.2.13-12.fc12.i686
SDL_mixer-devel-1.2.8-13.fc12.i686
SDL_image-devel-1.2.7-1.fc12.i686
SDL_image-1.2.7-1.fc12.i686
#+END_EXAMPLE

** 初始编译   
根据demo/sigmod2005/cube/README中的说明，
#+BEGIN_EXAMPLE
Platform:
        Linux 2.6x or 2.4x kernels with gcc-3.2 or higher.

Dependencies:

        (1) Borealis
        (2) NMSTL (/pro/sand/software/NMSTL)
        (3) SDL 1.2.7
        (4) SDL-mixer 1.2.5
        (5) SDL-image 1.2.3
        (6) xercesc 2.3.0
        (7) OpenGL, GLU

Compiling:
        (1) Setup and compile borealis includeing the tests, we use the version in subversion repository
        here: file:///pro/sand/games/svn/borealis/trunk borealis

        (2) Get the cube source code from subversion (file:///pro/sand/games/svn/cube/trunk) or get the tarfile.

        (3) cd cube/source/src

        (4) run ./setup
        (5) run configure e.g.,
        export SANDSOFT=/pro/sand/software
#+END_EXAMPLE

安装SDL版本有所不同，不影响编译。上面/Compiling/ 下的(1)(2)(3)描述的都
与下载的borealis不一致，(2)中的cube可以直接使用
demo/sigmod2005/cube/bot\under{}src下的源代码，(3)的路径应该
为:demo/sigmod2005/cube/bot\under{}src。另外执行(5)之前，需要修改configure文
件中SDL相关的的路径：由原来的
#+BEGIN_EXAMPLE
with_sdl_mixer=/usr/local
#+END_EXAMPLE
改为：
#+BEGIN_EXAMPLE
with_sdl_mixer=/usr
#+END_EXAMPLE
最终执行的操作如下：
#+BEGIN_EXAMPLE
cd demo/sigmod2005/cube/bot_src
./setup
./configure --with-xercesc=/home/borealis/builtTools/xerces --with-nmstl=/home/borealis/install_nmstl --with-borealis=/home/borealis/borealis
make
#+END_EXAMPLE

make的时候，会遇到如下错误和修改：
- 错误一
#+BEGIN_EXAMPLE
bot_util.h: In member function ‘bool TMultiChoice<C>::GetSelection(C&)’:
bot_util.h:539: 错误：‘pNode’ 在此作用域中尚未声明

bot_util.h: In member function ‘bool TMultiChoice<C>::GetSelection(C&) [with C = char*]’:
bot.cpp:1151:   instantiated from here
bot_util.h:539: 错误：依赖名 ‘TLinkedList<TMultiChoice<C>::SMultiChoice*>::node_s’ 被解析为非类型，但实例化却产生了一个类型
bot_util.h:539: 附注：如果您想指定类型，请使用 ‘typename TLinkedList<TMultiChoice<C>::SMultiChoice*>::node_s’
make[2]: *** [bot.o] 错误 1
make[2]: Leaving directory `/home/borealis/borealis/demo/sigmod2005/cube/bot_src/src'
make[1]: *** [all-recursive] 错误 1
make[1]: Leaving directory `/home/borealis/borealis/demo/sigmod2005/cube/bot_src'
make: *** [all] 错误 2
#+END_EXAMPLE
将bot\under{}util.h的539行：
#+BEGIN_EXAMPLE
539 TLinkedList<SMultiChoice*>::node_s *pNode = pChoiceList->GetFirst();
#+END_EXAMPLE
改为：
#+BEGIN_EXAMPLE
539 typename TLinkedList<SMultiChoice*>::node_s *pNode = pChoiceList->GetFirst();
#+END_EXAMPLE
- 错误二
#+BEGIN_EXAMPLE
/home/borealis/builtTools/gcc/lib/gcc/i686-pc-linux-gnu/4.1.1/../../../../include/c++/4.1.1/bits/fstream.tcc: In member function ‘virtual typename std::basic_filebuf<_CharT, _Traits>::int_type std::basic_filebuf<_CharT, _Traits>::underflow()’:
/home/borealis/builtTools/gcc/lib/gcc/i686-pc-linux-gnu/4.1.1/../../../../include/c++/4.1.1/bits/fstream.tcc:289: 错误：expected unqualified-id before ‘(’ token
/home/borealis/builtTools/gcc/lib/gcc/i686-pc-linux-gnu/4.1.1/../../../../include/c++/4.1.1/bits/fstream.tcc: In member function ‘virtual std::streamsize std::basic_filebuf<_CharT, _Traits>::xsputn(const _CharT*, std::streamsize)’:
/home/borealis/builtTools/gcc/lib/gcc/i686-pc-linux-gnu/4.1.1/../../../../include/c++/4.1.1/bits/fstream.tcc:612: 错误：expected unqualified-id before ‘(’ token
make[2]: *** [bot.o] 错误 1
make[2]: Leaving directory `/home/borealis/borealis/demo/sigmod2005/cube/bot_src/src'
make[1]: *** [all-recursive] 错误 1
make[1]: Leaving directory `/home/borealis/borealis/demo/sigmod2005/cube/bot_src'
make: *** [all] 错误 2
#+END_EXAMPLE
fstream.tcc:289的内容为： 
#+BEGIN_EXAMPLE
/home/borealis/builtTools/gcc/include/c++/4.1.1/bits/fstream.tcc 289行的内容为：
__ilen = std::min(__avail, __buflen);
#+END_EXAMPLE
在bot\under{}src/src/tools.h中定义了
#+BEGIN_EXAMPLE
#define max(a,b) (((a) > (b)) ? (a) : (b))
#define min(a,b) (((a) < (b)) ? (a) : (b))
#+END_EXAMPLE
因此是因为名称相同造成的，修改成其它的名称即可。

- 错误三
#+BEGIN_EXAMPLE
gamesubscriber.h: In constructor ‘GameSubscriber::GameSubscriber(NMSTL::InetAddress, NMSTL::InetAddress, NMSTL::InetAddress, NMSTL::ptr<std::vector<NMSTL::ptr<BufferedSocket>, std::allocator<NMSTL::ptr<BufferedSocket> > > >)’:
gamesubscriber.h:133: 错误：用作消歧义的 ‘template’ 只能用于模板内
tools.h: In constructor ‘vector<T>::vector()’:
tools.h:148: 警告：‘gp’ 的实参不依赖模板参数，所以 ‘gp’ 的声明必须可用
tools.h: In constructor ‘hashtable<T>::hashtable()’:
tools.h:223: 警告：‘gp’ 的实参不依赖模板参数，所以 ‘gp’ 的声明必须可用
make[2]: *** [client.o] 错误 1
#+END_EXAMPLE
g++-4.1.1不允许在构造函数中初始化动态变量，而gamesubscriber.h:133行，
在构造函数内，有下面的语句：
#+BEGIN_EXAMPLE
file name: gamesubscriber.h
133 m_deploy_qp = m_deploy_endpoint.template get<Borealis::QueryProcessor>("QueryProcessor");
#+END_EXAMPLE
因此注释掉该行内容，并且可以在以后使用的时候，对其进行初始化，将该行移
到gamesubscriber.cpp的355行第一次使用m\under{}deploy\under{}qp的前面:
#+BEGIN_EXAMPLE
file name: gamesubscriber.cpp
354  m_deploy_qp = m_deploy_endpoint.template get<Borealis::QueryProcessor>("QueryProcessor");
355    if ( !m_deploy_qp ) {
356        WARN << "No Borealis node selected for deploying queries.";
357        return false;
358    }
#+END_EXAMPLE

** 最后四个错误
- 上面的步骤后，还是不能正常运行，由于borealis源代码中有一个错误：
#+BEGIN_SRC C++ -n -r
file name: tool/head/DeployDiagram.cc
Status  DeployDiagram::deploy_table_schema(// Target node in _pending.
                                           string   endpoint)
{
    CatalogTable   *table;

    TableMap::iterator  table_it;

    for (table_it  = _topology._table_map.begin();
         table_it != _topology._table_map.end(); ++table) (ref:table)

#+END_SRC
line [[(table)]] 的初始化和条件变量为table\under{}it，而增量变量为table，导致该循
环无法退出。
- netio.cpp 的宕机
#+BEGIN_SRC C++ -n
void handle_incoming_tuples()
{
   ptr<StreamEvent> evt(new StreamEvent());

          if (handler_it != handler_end) {
              assert(evt->_tuple_size == handler_it->second.first); (ref:assert)
  ...
}
#+END_SRC
line [[(assert)]] 现在的borealis版本并不处理\under{}tuple\under{}size，因此它的值为0，导
致这个断言永远失败，必须注释掉。
- to\under{}server\under{}map 引发的错误
在cube.xml中有个字段定义：
#+BEGIN_EXAMPLE
    <field name="to_server_map"        type="string"  size="131"/>
#+END_EXAMPLE
但是实际的值为131，导致运行失败。
- metl3.cgz引发的错误
cube\under{}client启动的时候，需要读取metl3.cgz,因此需要将cube的packages.tar，
解压到cube目录下。

通过比对 AssaultCube，应该是其早期的版本

** 运行cube
在上一步编译中，执行cube/bot\unser{}src/setup后，会在cube目录下生成
run\under{}cube\under{}demo.sh文件，此文件跟borealis中其它如test/simple下的runtest文
件类似。从文件的game目标所列出的主要组合命令挨个分析：


#+BEGIN_SRC sh -n -r
game
        read_game_hosts $2 (ref:file)

        $0 clean  (ref:clean)
        $0 cls (ref:cls)
        sleep 1
        $0 metaoptimizer (ref:mp)
        sleep 3
        $0 borealis
        sleep 3

        for ip in ${HOSTS}; do
            env CLS_IP=${IP} IP="$ip" ${EXEC} bremote (ref:remote)
        done
        sleep 25

        $0 head (ref:head)
        sleep 3
        $0 gui-viz (ref:viz)
        exit 0
        ;;
#+END_SRC
+  line [[(file)]]  可以给出包含游戏主机ip地址的文件，通过[[(remote)]] 行和
  bremote所执行的命令知道，这些主机上将会启动borealis引擎。
+ line [[(clean)]] 删除一些以前运行的日志文件
+ line [[(cls)]] 与README文件中描述的“start the central lookup server”一
  致，但是在这个borealis版本中，并没有CentralLookupServer相关的源代码，
  在Makefile的一些注释中，发现些痕迹，并且从test下能运行的例子以及开
  发文档中，并不需要CentralLookupServer。应该是以前版本中的组件。接下
  来，[[(mp)]] 行中的metaoptimizer一样的被去掉了，由NHOptimizer代替。
+ line [[(head)]] 提交网络和网络布局文件到borealis节点。
#+BEGIN_SRC sh
 xterm -T BigGiantHead -geometry 80x20+20+50 -e env LD_LIBRARY_PATH=${LD_LIBRARY_PATH} sh -c "${BOREALIS_HEAD_HOME}/BigGiantHead ${QUERY_FILE} ${DEPLOY_FILE} 2>&1 | tee head.log" &
#+END_SRC
这行命令直接将两个文件cube.xml和cube\under{}deployment.xml提交到
borealis节点，但是现有的test/simple下的mytestdist和
test/composite/sunion/都是专门写一个函数如launchDiagram()，主要代码如下：
#+BEGIN_SRC C++ -n
    client = (HeadClient *)new HeadClient( InetAddress( HEAD_NODE,
                                                        DEFAULT_HEAD_PORT ));

    string query_file        = "cube.xml";
    string deployment_file   = "cube_deployment.xml";

    rpc = client->deploy_xml_file( query_file);
    if ( ! rpc.valid() )
    {
        WARN << "Error with query file " << rpc.stat();
        exit(0);
    }

    rpc = client->deploy_xml_file(deployment_file);
    if ( ! rpc.valid() )
    {
        WARN << "Error with deployment file " << rpc.stat();
        exit(0);
    }
#+END_SRC
因此原始的命令head也不能正确执行，将上面的c++代码生成deploy命令，并将
head的命令改成
#+BEGIN_SRC sh
xterm -T BigGiantHead -geometry 80x20+20+50 -e env LD_LIBRARY_PATH=${LD_LIBRARY_PATH} sh -c "${BOREALIS_HEAD_HOME}/BigGiantHead  2>&1 | tee head.log" &
#+END_SRC

+ line [[(viz)]] 没有准备运行
+ 最简单的运行，只用一个borealis节点，那么剩下的game代码如下
#+BEGIN_SRC sh -n
game
        $0 borealis 127.0.0.1:15000
        sleep 3

        $0 head
        sleep 3
        exit 0
        ;;
#+END_SRC

** 完整运行cube+borealis的步骤
+ 在一个终端运行
#+BEGIN_SRC sh
cd demo/sigmod2005/cube
./run_cube_demo game
#+END_SRC
+ 等到borealis节点和head都启动后，在另一个终端运行deploy命令：
#+BEGIN_SRC sh
cd demo/sigmod2005/cube/bot_src/src
./deploy
#+END_SRC
注： BigGiantHead收到远端提交命令后，只接收需要的文件名如这里的
cube.xml和cube\under{}deployment.xml，然后在当前运行BigGiantHead的目录
下找相应的文件，因此这里需要将cube/bot\under{}src/borealis\under{}if目录
下的两个xml文件拷贝到demo/sigmod2005/cube目录下，否则得到读文件失败的
信息。


* compile borealis i386 in FC20.x86_64
- config files
#+BEGIN_SRC sh
diff -r borealis/src/configure.ac borealis-ok/src/configure.ac
14,15c14,15
< CFLAGS="-g -Wall -Werror"
< CXXFLAGS="-g -Wall -Werror"
---
> CFLAGS="-g -Wall -Werror -m32"
> CXXFLAGS="-g -Wall -Werror -Wno-deprecated -m32"
#+END_SRC

#+BEGIN_SRC sh
diff -r borealis/test/configure.ac borealis-ok/test/configure.ac
14,15c14,15
< CFLAGS="-g -Wall -Werror"
< CXXFLAGS="-g -Wall -Werror"
---
> CFLAGS="-g -Wall -Werror -m32"
> CXXFLAGS="-g -Wall -Werror -m32"
#+END_SRC

#+BEGIN_SRC sh
diff -r borealis/tool/configure.ac borealis-ok/tool/configure.ac
14,15c14,15
< CFLAGS="-g -Wall -Werror"
< CXXFLAGS="-g -Wall -Werror"
---
> CFLAGS="-g -Wall -Werror -m32"
> CXXFLAGS="-g -Wall -Werror -m32"
#+END_SRC
#+BEGIN_SRC sh

#+END_SRC
#+BEGIN_SRC sh
diff -r borealis/utility/client/configure.ac borealis-fc20/utility/client/configure.ac
14,15c14,15
< CFLAGS="-g -Wall -Werror"
< CXXFLAGS="-g -Wall -Werror"
---
> CFLAGS="-g -Wall -Werror -m32"
> CXXFLAGS="-g -Wall -Werror -m32"

#+END_SRC

* visual viewer
Up to now, I verified whether these visual montors with Java were able
to run.

- tool/viewer
#+BEGIN_SRC sh
  [borealis@localhost viewer]$ ant run
#+END_SRC

it will run a GUI, it can load network query, such as fauttest.xml, in
Editor option, the network appears.

- tool/monitor
after simply running make cmd, monitor.jar is produced in lib, for
testing this monitor:
#+BEGIN_SRC sh
[borealis@localhost monitor]$ java -cp ./lib/ha.jar:./lib/monitor.jar:./lib/clientApi.jar:./lib/medusaXmlRpc.jar:./lib/xerces.jar ../../demo/ha/ha_config.xml 
#+END_SRC

the last argument is necessary, and it should be another file that
must include item "layout".
the above cmd will start a window. the concrete details are not clear.

ha.jar in the above cmd, it includes two files CountSchema.java and
PacketSchema.java. For getting ha.jar:
#+BEGIN_SRC sh
cd utility/unix
[borealis@localhost unix]$ ./build.borealis.sh -demo ;CountSchema.java and PacketSchema.java will be compiled.
cd ../../demo/ha
[borealis@localhost ha]$ jar cvf ./ha.jar ./*.class
#+END_SRC

- tool/statsView
this tool is used in [balazinska06][fn:2]'s Figure 5-4. It can be
produced by make under tool/statsView, and:

#+BEGIN_SRC sh
java -cp ./lib/monitor.jar monitor.Monitor 127
#+END_SRC

the last arg need more study.

* AvailabilityMonitor
#+BEGIN_SRC c
monitor_nodes() {
...
    // Re-scheduling monitoring task
    (new CallbackTimer(_my_loop,wrap(this,&AvailabilityMonitor::monitor_nodes)))->arm(Time::now() + Time::msecs(_ping_interval));

}

#+END_SRC

* ConsistencyMgr
#+BEGIN_SRC c++
void ConsistencyMngr::update_state(ConsistencyState new_state)
#+END_SRC

#+BEGIN_SRC c++
Status ConsistencyMngr::handle_control_tuples(ptr<StreamEvent> event)
#+END_SRC

#+BEGIN_SRC c++
typedef map<string, set<string> > ReplicaMap;
#+END_SRC

#+BEGIN_SRC c++
    /// Configuration of the query diagram.
    ///
    struct Topology
    {
        CatalogSchema::SchemaMap    _schema_map;       // Tuple Description
        StreamMap       _stream_map;       // Stream
        BoxMap          _box_map;          // Box
        TableMap        _table_map;        // Tables
        QueryMap        _query_map;        // Queries - Move to DeployDiagram.
    };

#+END_SRC

#+BEGIN_SRC c++
    // Network oriented approach to inter-site connections.
    typedef   map<Name, CatalogSubscription>            SubscriptionMap;
    typedef   map<InetAddress, SubscriptionMap>         StreamLinkMap;

#+END_SRC

#+BEGIN_SRC c++
// xml rpc
#define XML_RPC_PORT_OFFSET 1

// Fast data path
#define DATA_PORT_OFFSET 2

#+END_SRC

#+BEGIN_SRC c++
struct medusa_components
{
    IOEventLoop             &_loop;
    InetAddress              _addr;
//    ptr<HA>                   _ha;
    ptr<AvailabilityMonitor>  _avail_mon;
    ptr<LocalLoadShedder>     _local_ls;
    ptr<NHLoadShedder>        _nh_ls;
    ptr<NHOptimizer>          _nhopt;
    ptr<QOSOptimizer>         _qosopt;
    ptr<QueryProcessor>       _qp;

#+END_SRC

* SUnionQBox
For FT, SUnionQBox creates a Bucket per 500 millseconds, all inputing
tuples with different timestamp will be taken into different buckets
according the code:

#+BEGIN_SRC c++
millseconds = tuple_timestamp.to_millseconds()/500

interval_nb = timestamp_to_interval_nb(tuple_timestamp) 


typedef map<long long, ptr<Bucket> > Buckets;

Buckets _buckets;

#+END_SRC
interval_nb is used as _buckets' key, when getting a new tuple,
SUnionQBox first looks up a bucket from _buckets based on interval_nb,
and inserts the new tuple into the bucket, or creates a new bucket and
inserts the tuple into it.


dst_tuple.set_tuple_type(TupleType::UNDO) <- SControlQBox::emit_undo_tuple(const Tuple& src_tuple) <-
SOutputQBox::unpack_state()<- recovery_task::perform_task()  

SUnionBoxNoBucketState -> AbstractBoxState

SControlQBox::emit_undo_tuple()[set_tuple_type(TupleType::UNDO]<-
SOutputQBox::unpack_state() <- AuroraNode::recover() <-
ConsistencyMgr::launch_reconciliation() <-
ConsistencyMgr::request_authorization_response() <-
ConsistencyMgr::request_authorization()[if type == TupleType::RECONCILIATION_REQUSET] <-
ConsistencyMgr::handle_control_tuples() <-
ConsistencyMgr::monitor_control_stream()[
_qp._data_path.add_local_output_path_client(control_stream_name,
wrap(this,&ConsistencyMngr::handle_control_tuples));] 
* Footnotes



[fn:1] In video games, a bot is a type of weak AI expert system
software which for each instance of the program controls a player in
deathmatch, team deathmatch and/or cooperative human player, most
prominently in the first-person shooters (FPSs)。

[fn:2] Fault-Tolerance and Load Management in a Distributed Stream Processing System.
Magdalena Balazinska. PhD dissertation.



