#+STARTUP: showall indent
#+STARTUP: hidestars
#+OPTIONS:   H:2 num:nil toc:nil \n:nil ::t |:t -:t f:t *:t <:t

#+OPTIONS:   tex:t  d:nil todo:t pri:nil tags:not-in-toc
#+BEGIN_HTML
---
category: computer science and enginneering
layout: post
title: "Notes of Hadoop"
Tags: ["Big Data", Hadoop]
---
#+END_HTML

* 执行一个Mapreduce应用时，Hadoop内部执行流程
在每一个mapreduce分析任务中，都会调用JobClient.runJob(conf)，那么在这之后，hadoop中的mapreduce内部都做了哪些工作呢？

首先创建了JobClient实例
#+BEGIN_SRC java
	public static RunningJob runJob(JobConf job) throws IOException {
		JobClient jc = new JobClient(job);
		...
	}
#+END_SRC
看JobClient的构造函数
#+BEGIN_SRC java
	public JobClient(JobConf conf) throws IOException {
		setConf(conf);
		init(conf);
	}
#+END_SRC
这里重点看init(conf)
#+BEGIN_SRC java
	public void init(JobConf conf) throws IOException {
		String tracker = conf.get("mapred.job.tracker", "local");
			if ("local".equals(tracker)) {
				this.jobSubmitClient = new LocalJobRunner(conf);
				} else {
					this.jobSubmitClient = createRPCProxy(JobTracker.getAddress(conf), conf);
				}        
			}
#+END_SRC
根据mapred.job.tracker是否为local，确定JobSubmissionProtocol类型的jobSubmitClient最终是完成本地通信还是远程RPC通信。其中通信协议的实现由LocalJobRunner或createRPCProxy完成。

在JobClient.runJob(conf)创建了JobClient实例后，由下面的语句来提交任务
#+BEGIN_SRC java
	public static RunningJob runJob(JobConf job) throws IOException {
		JobClient jc = new JobClient(job);
		...
			running = jc.submitJob(job);
		...
	}
#+END_SRC
在JobClient中的submitJob方法中，先完成一些准备工作(现在不清楚)，最后关键一步是提交任务,
#+BEGIN_SRC java
	public RunningJob submitJob(JobConf job) throws FileNotFoundException, 
        InvalidJobConfException, IOException
	{
		...
			JobStatus status = jobSubmitClient.submitJob(jobId);
				if (status != null) {
					return new NetworkedJob(status);
				} else {
					throw new IOException("Could not launch job");
				}
			}
#+END_SRC
如果mapred.job.tracker为LocalJobRunner的submitJob方法，则会调用
#+BEGIN_SRC java
	public JobStatus submitJob(JobID jobid) throws IOException {
		return new Job(jobid, this.conf).status;
	}
#+END_SRC
这里的Job实例是在LocalJobRunner中设计的private类Job：
#+BEGIN_SRC java
	private class Job extends Thread
		implements TaskUmbilicalProtocol {
	...
		public Job(JobID jobid, JobConf conf) throws IOException {
	...
		status = new JobStatus(id, 0.0f, 0.0f, JobStatus.RUNNING);
	...
		jobs.put(id, this);
			this.start();
		}
	}
#+END_SRC
在Job的构造函数Job(JobID jobid, JobConf conf)中，将当前状态设为RUNNING，然后将自身存放到 LocalJobRunner 的HashMap中，最后启动自身线程。
