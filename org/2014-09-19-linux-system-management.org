#+STARTUP: showall indent
#+STARTUP: hidestars
#+OPTIONS:   H:2 num:nil toc:nil \n:nil ::t |:t -:t f:t *:t <:t

#+OPTIONS:   tex:t  d:nil todo:t pri:nil tags:not-in-toc
#+BEGIN_HTML
---
layout: post
title: "General Knowledge of Linux System Management"
description: ""
tags: [linux, tools]
---
{% include JB/setup %}

#+END_HTML

* 将find找到的所有文件使用cp拷贝 到指定的目录
find ./openfiler/ -name "*.php" -exec cp {} ./NAS-storage/ \;

+ -exec 参数后面跟的是 command 命令(如这里的cp)，
+ '{}'  使用{}来表示文件名，也就是find前面处理过程中过滤出来的文件，用于command命令进行处理
+ ;  command命令的终止，使用 ';' (分号）来判定，在后面必须有一个';',分号前必须有空格；对于不同的系统，直接使用分号可能会有不同的意义， 使用转义符 '\'在分号前明确说明，对于前面我们遇到的问题，主要就是这个原因引起的！
* RJ45
以下内容摘自wikipedia

1. 差分传输是一种信号传输的技术，区别于传统的一根信号线一根地线的做法，差分传输在这两根线上都传输信号，这两个信号的振幅相等，相位相反。在这两根线上的传输的信号就是差分信号。信号接收端比较这两个电压的差值来判断发送端发送的是逻辑0还是逻辑1。在电路板上，差分走线必须是等长、等宽、紧密靠近、且在同一层面的两根线。

2. 8P8C，也称之为RJ45，是以太网使用双绞线连接时常用的连接器插头。 8P8C的意义是8个位置（Position）也就是8个凹槽，8个触点（Contact）也就是8个金属接点。

连线颜色

在T568A中，与之相连的8根线分别定义为：绿白、绿；橙白、蓝；蓝白、橙；棕白、棕。在T568B中，与之相连的8根线分别定义为：橙白、橙；绿白、蓝；蓝白、绿；棕白、棕。其中橙白色和橙色组成一对差分传输线，绿白色和绿色组成一对差分传输线，蓝白色和蓝色组成一对差分传输线，棕白色和棕色组成一对差分传输线。T568A可以跟早期的USOC向下兼容，The United States National Communication Systems Federal Telecommunications Recommendations 不使用 T568B。

连线信号

在百兆以太网中，仅适用1、2、3、6四根线,差分信号传输方式，减少电磁干扰，其中1、2为TX(发送)（拧在一起），3、6为RX（接收）拧在一起。因此直连线就是两端同为EIA-568-A或者EIA-568-B，而以太网交叉线就是一端使用EIA-568-A，另一端使用EIA-568-B的连接方法。

在千兆以太网或者以太网供电中，全部的四对差分对都被使用。

T568B是RJ45端口连接双绞线时使用的一种线序，又称TIA/EIA-568-B线序: 橙白 橙 绿白 蓝 蓝白 绿 棕白 棕

T568A是RJ45端口连接双绞线时使用的一种线序，又称TIA/EIA-568-A线序：绿白 绿 橙白 蓝 蓝白 橙 棕白 棕


* 配置 SSH 的无密码公钥认证的过程,需要如下操作

如下步骤都应该在本地主机(192.168.1.103)终端命令行上执行，不要在emacs的shell中执行

#+BEGIN_SRC sh
ssh-keygen -t rsa
cat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys
#+END_SRC

完成后，将公钥拷贝到要登录的远程主机(192.168.1.107)上：

#+BEGIN_SRC sh
[abelard@localhost ~]$ ssh-copy-id -i ~/.ssh/id_rsa.pub 192.168.1.107
#+END_SRC

现在就可以无密码登录到远程主机上了，只是用户名必须是同一个，(网路上提议拷贝
时用borealis@192.168.1.107，但是试验没有成功。)
#+BEGIN_SRC sh
ssh -l abelard192.168.0.88
#+END_SRC


如果这时候出现如下错误：
#+begin_example
Agent admitted failure to sign using the key
#+end_example
使用下面的方法：
#+begin_example
ssh-add   ~/.ssh/id_rsa  
#+end_example

* 建立 ssh 连接,只要將公鑰複製到 ~/.ssh/authorized\_keys 就可以利用金鑰登入,而不需要建立密碼.如出现下面的错误？

Agent admitted failure to sign using the key

解決方式 使用 ssh-add 指令將私钥加進來 （根据个人的密匙命名不同更改 id\_rsa）
# ssh-add   ~/.ssh/id_rsa  
* 按照步骤配置完无密码ssh登录后，使用ssh登录，还是需要密码，怎么办？
很可能是因为authorized_keys 文件的权限不对，使用下面的命令改为：
#+begin_example
[abelard@dillon82 ~]$ chmod 600 .ssh/authorized_keys 
#+end_example
* 怎么让qemu的guest os通过host 的bridge上网以及让guest os 在host所在的局域网内 (主机操作系统为 Fedora 16 x86\_64)
说明：使用qemu的网桥模式，这样由qemu创建的guest os和
主机操作系统在同一个局域网内，即局域网内的所有主机都可以访问
该guest os。当然由于网桥可以在直接网桥方式和NAT/Masquerading
方式下工作，因此guest 和 host可以在同一个子网内（直接桥接方
式）也可以将guest隐藏起来，不与host在同一个子网，如下图
(http://en.gentoo-wiki.com/wiki/KVM#Networking_2)。

直接网桥模式:
#+BEGIN_EXAMPLE    
                      host   
           +-----------------------+
           |                       |                             
	   |                       |        KVM GUEST1
           |  +-----------+        |     +--------------+ 
 LAN ------+--+---  eth0  |   +----------+---  nic0     |      
           |  |     tap0 -----+    |     | 192.168.0.83 |      KVM GUEST2         
           |  |     tap1 -----+    |     +--------------+  +--------------+
           |  +-----------+   |    |                       |              |
           |          br0     +----+-----------------------+---- nic0     |
           |    192.168.0.88       |                       | 192.168.0.84 |
           +-----------------------+                       +--------------+
#+END_EXAMPLE

NAT/Masquerading （网络地址转换/隐藏）网桥模式:
#+BEGIN_EXAMPLE
                      host   
           +-----------------------+
	   |                       |        KVM GUEST1
           |   192.168.1.88        |     +--------------+ 
 LAN ------+-----  eth0            |     |              |
           |        ^              |     |              |
           |        |              |     |              |
           |  +-----------+   +----+-----+-----nic0     |   
           |  |     tap0 -----+    |     | 192.168.0.83 |      KVM GUEST2         
           |  |     tap1 -----+    |     +--------------+  +--------------+
           |  +-----------+   |    |                       |              |
           |          br0     +----+-----------------------+---- nic0     |
           |    192.168.0.88       |                       | 192.168.0.84 |
           +-----------------------+                       +--------------+
#+END_EXAMPLE

第一步：安装和设置网桥（参考[[http://www.howtoforge.com/virtualization-with-kvm-on-a-fedora-14-server][Virtualization With KVM On A Fedora 14 Server]])

1. 安装网桥和准备工作
#+begin_example
yum install bridge-utils
#+end_example
为了让网桥顺利工作，需要关闭Network Manager，因为Network Manager好像不
支持网桥启动，可以先查看Network Manager是否启动，由于从Fedora14以后，
采用了[[http://freedesktop.org/wiki/Software/systemd][Systemd]] 作为linux的系统和服务管理器，因此查看和关闭服务使用：
#+begin_example
systemctl status networkmanager.service
systemctl stop networkmanager.service
#+end_example
永久关闭该服务使用：
#+begin_example
chkconfig NetworkManager off
chkconfig --levels 35 network on
#+end_example
这时候重启网络，看看什么情况
#+begin_example
systemctl restart network.service
#+end_example
2. 开始配置网卡和网桥
/etc/sysconfig/network-scripts/ifcfg-p4p1的内容如下：重点需要关注的是
这里的NM_CONTROLLED="no",而不是"yes"，就是说要关闭network manager，另
外就是加上了BRIDGE=br0。 (至于为什么是p4p1
不是eth0等，那是fedora新版本采用的名称)
#+begin_example
DEVICE=p4p1
#BOOTPROTO=static
ONBOOT=yes
NM_CONTROLLED="no"
TYPE=Ethernet
DEFROUTE=yes
IPV4_FAILURE_FATAL=yes
IPV6INIT=no
NAME="System p4p1"
UUID=5dd47203-fffb-671a-4fd0-4cff98347a3b
HWADDR=00:25:64:8E:58:8C
PREFIX0=24
BRIDGE=br0
#+end_example
还需要配置网桥，使用/etc/sysconfig/network-scripts/ifcfg-br0文件来完成，
可以看到该文件中配置了ip,gateway,dns等
#+begin_example
DEVICE=br0
TYPE=Bridge
BOOTPROTO=static
ONBOOT=yes
IPADDR=192.168.0.88
NETMASK=255.255.255.0
GATEWAY=192.168.0.1
DNS1=192.168.0.1
DELAY=0
STP=off
#+end_example
这时候重启网络
#+begin_example
systemctl restart network.service
#+end_example
正常的情况下应该看到如下信息：
#+begin_example
[abelard@localhost ~]$ ifconfig
br0       Link encap:Ethernet  HWaddr 00:25:64:8E:58:8C  
          inet addr:192.168.0.88  Bcast:192.168.0.255  Mask:255.255.255.0
          inet6 addr: fe80::225:64ff:fe8e:588c/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:11611 errors:0 dropped:0 overruns:0 frame:0
          TX packets:10348 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:8935226 (8.5 MiB)  TX bytes:1445532 (1.3 MiB)

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:8 errors:0 dropped:0 overruns:0 frame:0
          TX packets:8 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:480 (480.0 b)  TX bytes:480 (480.0 b)

p4p1      Link encap:Ethernet  HWaddr 00:25:64:8E:58:8C  
          inet6 addr: fe80::225:64ff:fe8e:588c/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:12061 errors:0 dropped:0 overruns:0 frame:0
          TX packets:10384 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:9225251 (8.7 MiB)  TX bytes:1497788 (1.4 MiB)
          Interrupt:16 
#+end_example
可以使用nslookup www.google.com命令看看是否有问题！

第二步，创建tap设备
  有了网桥以后，先使用
#+begin_example
[abelard@localhost ~]$ sudo lsmod | grep tun
#+end_example
如果没有任何信息，使用
#+begin_example
[abelard@localhost ~]$ sudo modprobe tun
[abelard@localhost ~]$ sudo lsmod | grep tun
tun                    14111  0 
#+end_example
如果还没有信息，就需要google一下，查找怎么yum一个tun模块。有信息的话，
就继续。
使用tunctl命令创建tap设备,并将tap设备添加到网桥br0中，
#+begin_example
[abelard@localhost ~]$ sudo tunctl -b  -t tap0
[abelard@localhost ~]$ brctl addif br0 tap0
[abelard@localhost ~]$ sudo ifconfig tap0 up
[abelard@localhost ~]$ ifconfig
br0       Link encap:Ethernet  HWaddr 00:25:64:8E:58:8C  
          inet addr:192.168.0.88  Bcast:192.168.0.255  Mask:255.255.255.0
          inet6 addr: fe80::225:64ff:fe8e:588c/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:12165 errors:0 dropped:0 overruns:0 frame:0
          TX packets:10867 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:9116034 (8.6 MiB)  TX bytes:1529806 (1.4 MiB)

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:8 errors:0 dropped:0 overruns:0 frame:0
          TX packets:8 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:480 (480.0 b)  TX bytes:480 (480.0 b)

p4p1      Link encap:Ethernet  HWaddr 00:25:64:8E:58:8C  
          inet6 addr: fe80::225:64ff:fe8e:588c/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:12677 errors:0 dropped:0 overruns:0 frame:0
          TX packets:10903 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:9431240 (8.9 MiB)  TX bytes:1584348 (1.5 MiB)
          Interrupt:16 

tap0      Link encap:Ethernet  HWaddr 26:A1:36:5F:18:64  
          UP BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:500 
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
#+end_example
这时候，网桥和tap设备都可以工作了，意味着qemu的网桥模式可以开始。

第三步 在qemu中使用网桥模式

使用过两种方式，

（1） 不设置启动脚本 
#+begin_example
sudo qemu-kvm -hda CentOs5.7.img -net nic,macaddr=00:1d:92:ab:3f:78 -net tap,ifname=tap0,script=no,downscript=no -boot c
#+end_example
 这种方式，因为没有用到启动脚本(script=no,downscript=no),因此需要手动来使用上面的命令：
#+begin_example
[abelard@localhost ~]$ brctl addif br0 tap0
[abelard@localhost ~]$ sudo ifconfig tap0 up
#+end_example
（2） 设置qemu网络启动脚本/etc/qemu-ifup
#+begin_example
#!/bin/sh
brctl addif br0 $1
ifconfig $1 up 0.0.0.0 promisc
#+end_example
使用以下命令就可以启动guest os，并且可以在同一个子网中访问这个guest（192.168.0.81）
了，
#+begin_example
sudo qemu-kvm -hda CentOs5.7.img -net nic,macaddr=00:1d:92:ab:3f:78 -net tap,ifname=tap0  -boot c
#+end_example
或
#+begin_example
sudo qemu-kvm -hda CentOs5.7.img -net nic,macaddr=00:00:00:00:00:00 -net tap,ifname=tap0 -boot c
#+end_example
或
#+begin_example
sudo qemu-kvm -hda CentOs5.7.img -net nic -net tap,ifname=tap0 -boot c
#+end_example

* 使用vnc来显示qemu客户OS
  + 需要在主机操作系统(如Fedora 12)上安装vnc服务器和客户端软件，如
    tigervnc,tigervnc-server
  + 使用带vnc参数启动qemu的客户操作系统
#+begin_example
[abelard@dillon vmware]$ sudo qemu-kvm -m 1G -hda Centos-mini.img -vnc 192.168.0.88:2  -boot c
#+end_example
    其中192.168.0.88为安装有vnc服务器软件的主机ip,‘:2’为端口号 ‘5900+2’
  + 在主机os上启动vnc客户端来显示客户os
#+begin_example
[abelard@dillon ~]$ vncviewer 192.168.0.88:5902
#+end_example

* 使用rsync命令从一台机器的内容同步到另一台机器时，会出现用户名和组名为数字
假设：从192.168.0.109 同步到 192.168.0.0.88上，在109上的信息是：
-rw-r--r-- 1 jiangshan jiangshan  2896 11月 22 08:11 README
同步到88上以后：
-rw-r--r-- 1 1000 1000  2896 11月 22 08:11 README

显示为1000的原理是：在109上jiangshan的用户名和组ID为1000，在同步到88的
时候，先去/etc/passwd上查找，如果有1000的用户，则显示为其用户名，没有
的话就显示数字。

这是因为在88的机器上没有用户和组为jiangshan的，为了同步以后保持原样，
在88上使用如下命令创建用户名：
useradd jiangshan -u 1000

再同步后，88上就变成和109上一样了。

* 为linux安装新的字体(环境为Fedora 12 x86_64)
参考：[[http://blog.csdn.net/evanlinux/article/details/5507343][Fedora12下安装微软雅黑字体 ]]
1. 先从windows下拷贝你需要的字体(目录为C:\windows\fonts),如
   simsun.ttc,simhei.ttf,或或从网上下载需要的字体，如apple的MONACO.ttf
   等宽字体， 将这些字体文件放在/usr/share/fonts/myFonts下，myFonts是
   自己建的目录。
2. 执行如下命令
#+begin_example
cd /usr/share/fonts/myFonts
mkfontscale
mkfontdir
fc-cache -fv
#+end_example
3. 打开“系统”——“首选项”——“观感”——“外观”，在字体选项卡中就可以找到“宋
   体，MONACO”等等了

* 架设dns服务器(环境为Fedora 12 x86_64)
参考 [[http://linux.vbird.org/linux_server/0350dns.php][第十九章、主機名稱控制者： DNS 伺服器]]
1. 先检查是否已安装相应的包
#+begin_example
[abelard@dillon ~]$ rpm -qa | grep '^bind'
bind-9.6.2-5.P2.fc12.x86_64
bind-libs-9.6.2-5.P2.fc12.x86_64
bind-utils-9.6.2-5.P2.fc12.x86_64
#+end_example
2.配置 /etc/named.conf
#+begin_example
options {
	//listen-on port 53 { any; };//any 代表全部接受
	//listen-on-v6 port 53 { ::1; };
	directory 	"/var/named";
	dump-file 	"/var/named/data/cache_dump.db";
        statistics-file "/var/named/data/named_stats.txt";
        memstatistics-file "/var/named/data/named_mem_stats.txt";
	allow-query     { any; };
	recursion yes;
	allow-transfer {any;}; //不许别人进行zone转移
};

logging {
        channel default_debug {
                file "data/named.run";
                severity dynamic;
        };
};

zone "." IN {
	type hint;
	file "named.ca";
};
zone "dillon.cloud" IN{ //新建的zone
	type master;
	file "named.dillon.cloud";
};

zone "0.168.192.in-addr.arpa" IN{ //新建的zone
  	type master;
	file "named.192.168.0";
};

include "/etc/named.rfc1912.zones";

#+end_example

3.新建/var/named/named.dillon.cloud

#+begin_example
$TTL 600
@	IN SOA master.dillon.cloud. cloud.www.dillon.cloud.(
	2011080401 3H 15M 1W 1D)
@	IN NS master.dillon.cloud.
master.dillon.cloud.	IN A 192.168.0.88
@	IN MX 10 www.dillon.cloud

www.dillon.cloud. IN A 192.168.0.88
#+end_example

4.新建/var/named/named.192.168.0
#+begin_example
$TTL 600
@ IN SOA master.dillon.cloud. cloud.www.dillon.cloud.(
	2011080401 3H 15M 1W 1D)
@ IN NS master.dillon.cloud.
88 IN PTR master.dillon.cloud.

88 IN PTR www.dillon.cloud
#+end_example

5.测试
5.1 开启bind
#+begin_example
[abelard@dillon ~]$ sudo /etc/init.d/named start
启动 named：                                               [确定]
#+end_example
如果希望每次系统自动启动named,使用
#+begin_example
[abelard@dillon ~]$ sudo chkconfig named on
#+end_example
5.2 为了使用自己的dns，在/etc/resolv.conf添加dns服务器的ip
#+begin_example
nameserver 192.168.0.88
#+end_example
5.3 测试正反解
#+begin_example
[abelard@dillon ~]$ nslookup 192.168.0.88
Server:		192.168.0.88
Address:	192.168.0.88#53

88.0.168.192.in-addr.arpa	name = master.dillon.cloud.
88.0.168.192.in-addr.arpa	name = www.dillon.cloud.0.168.192.in-addr.arpa.

[abelard@dillon ~]$ nslookup www.dillon.cloud
Server:		192.168.0.88
Address:	192.168.0.88#53

Name:	www.dillon.cloud
Address: 192.168.0.88
#+end_example
5.4 启动后，出现错误怎么办
查看
#+begin_example
[abelard@dillon ~]$ sudo tail -f -n 60 /var/log/messages 
#+end_example
* 查看已安装的perl模块
#+begin_example
#!/usr/bin/perl 

use ExtUtils::Installed; 
my $instmod = ExtUtils::Installed->new(); 
foreach my $module ($instmod->modules()) { 


my $version = $instmod->version($module) || "???"; 
printf( "%-12s — %s\n", $module, $version);
#print "$module -- $version\n"; 
} 
#+end_example

* 列出目前在cpan中可用的模块
执行如下命令：
#+begin_example
perl -MCPAN -e shell 
Terminal does not support AddHistory.

cpan shell -- CPAN exploration and modules installation (v1.9800)
Enter 'h' for help.

cpan[1]> m
#+end_example
* 安装perl模块(已安装MediaWikiDump为例)
有两种方式：手动和自动，自动的好处是那些依赖会自动安装，像Fedora的yum
一样，但是如果安装的过程中出错，没法知道错误的原因。

 + 下载 Parse-MediaWikiDump-1.0.6.tar.gz 并解压，之后执行如下命令
   
#+begin_example
>perl Makefile.PL
>make
>make test (optional)
>make install 
#+end_example

 + 自动安装
#+begin_example
#+begin_example
perl -MCPAN -e shell 
Terminal does not support AddHistory.

cpan shell -- CPAN exploration and modules installation (v1.9800)
Enter 'h' for help.

cpan[1]> install Parse::MediaWikiDump

#+end_example

* perl模块的卸载
+ 删除相关的pm文件就可以了
首先，使用下面的命令列出pm文件的可能位置，

#+begin_example
$ perl -e 'print join "\n",@INC'
/usr/local/lib64/perl5/site_perl/5.10.0/x86_64-linux-thread-multi
/usr/local/lib/perl5/site_perl/5.10.0
/usr/lib64/perl5/vendor_perl/5.10.0/x86_64-linux-thread-multi
/usr/lib/perl5/vendor_perl/5.10.0
/usr/lib/perl5/vendor_perl
/usr/lib64/perl5/5.10.0/x86_64-linux-thread-multi
/usr/lib/perl5/5.10.0
/usr/lib/perl5/site_perl
#+end_example
在这些位置里找到你关心的模块文件，比如version
#+begin_example
# ls /usr/lib64/perl5/5.10.0/x86_64-linux-thread-multi/version* -l
-r--r--r-- 1 root root 6494 12月 10 2010 /usr/lib64/perl5/5.10.0/x86_64-linux-thread-multi/version.pm
-r--r--r-- 1 root root 9816 11月 28 2010 /usr/lib64/perl5/5.10.0/x86_64-linux-thread-multi/version.pod

/usr/lib64/perl5/5.10.0/x86_64-linux-thread-multi/version:
总用量 32
-r--r--r-- 1 root root 24861  3月 11 2010 Internals.pod
-r--r--r-- 1 root root   505 12月 10 2010 vxs.pm
#+end_example
把这几个version相关的目录和文件删除就可以了
+ 
* 查看linux下某个端口被哪个程序占用,如想查看端口为5000被谁占用
使用命令：
#+begin_example
[abelard@dillon ~]$ netstat -tuanp | grep "5001"
#+end_example
* 用yum安装rpm文件
  如果rpm文件如AdobeReader_chs-8.1.7-1.i486.rpm，在Fedora 16
  x86_64的情况下，需要很多32位的依赖包，用rpm -ivh安装，会带
  来很多痛苦，用yum安装，所有依赖包，它会自己帮你去找
#+begin_example
 sudo yum install Downloads/AdobeReader_chs-8.1.7-1.i486.rpm 
#+end_example
* diff
If you are only interested to see the files that differ, you may use:

diff -qr dir_one dir_two | sort

Option "q" will only show the files that differ but not the content that differ, and "sort" will arrange the output alphabetically.
