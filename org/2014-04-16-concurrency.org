#+STARTUP: showall indent
#+STARTUP: hidestars
#+OPTIONS:   H:2 num:nil toc:nil \n:nil ::t |:t -:t f:t *:t <:t

#+OPTIONS:   tex:t  d:nil todo:t pri:nil tags:not-in-toc

#+BEGIN_HTML
---
category: computer science and enginneering
layout: post
title: "Concurrency"
tags: [Concurrency, Linux]
---
#+END_HTML


* linux下的并发基础知识
在多核(multi core)、多cpu(multi cpu)的时代，构建分布式处理系统，高并发
成为常用术语，但提到高并发时，肯定会问的一个是，cpu、OS和应用程序到底是如何来
满足高并发的呢？ 

- CPU 无论是多核还是单核，都是以task[fn:1]为单位执行或说管理，因此，对
  于单核，任何时候只有一个task在运行，对多核或多cpu，同时可以运行多个
  task，为并发和并行提供硬件基础。

- Linux CPU的task，linux中对应为thread或process，其源代码结构使用
  task_struct。 那线程在linux下的情况为，[fn:2]早期的linux内核，直到2.0, 才支持POXIS Thread，称为LinuxThread，
  通过克隆(指系统调用clone)整个进程和使用一个特定的“管理者线程”来提
  供多线程的面貌，并添加到glibc中，与2003年IBM发布的NGTP的M：N线程模型
  (m个用户空间线程映射到n个内核空间线程)相比，Linux一直采用1：1的线程
  模型，并从2.6以后，将其称为NPTL的线程组件加入到内核中，同时称为glibc
  的一部分。由此可见，创建的内核线程(kernel thread)和(user thread)，最
  终都能作为linux的调度单元，多个线程能同时运行在不同的CPU核或CPU上。
  因此，为并发提供重要的系统软件基础。
- 应用程序 CPU和linux具备了高并发的基础，但是多个线程共享进程的内存空
  间和其它资源，因此所有多线程应用程序，都需要考虑竞争条件(race
  condition)、互斥(mutually exclusive)和死锁(dead lock)等并发所带来的
  经典问题。
[fn:1] A task is a unit of work that a processor can dispatch, execute, and suspend. It can
be used to execute a program, a task or process, an operating-system service utility,
an interrupt or exception handler, or a kernel or executive utility. Intel® 64 and IA-32 Architectures
Software Developer’s Manual Volume 3A: System Programming Guide, Part
1 7.1 TASK MANAGEMENT OVERVIEW
[fn:2] http://www.drdobbs.com/open-source/nptl-the-new-implementation-of-threads-f/184406204#l2
