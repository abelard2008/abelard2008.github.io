---
layout: post
title: "Java的内部类和嵌套类"
tags: ["language"]
---
{% include JB/setup %}
<p>
Java的内部类和嵌套类<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup>，可以声明为：private，protect，public或package
private。 嵌套类静态的(static)和内部类非静态的(non-static)。
它们是将它括在内的那个类(外围类)的成员。非静态内部类可以访问它的外围
类的其它成员(即使是私有的)，静态类不能访问外围类的其它成员。
</p>

<p>
通常将两类统称为内部类。
</p>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">访问和实例化</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>静态嵌套类
</li>
</ul>
<div class="org-src-container">

<pre class="src src-java"><span class="linenr">1: </span><span style="color: #81a2be;">OuterClass</span>.StaticNestedClass
<span class="linenr">2: </span>
<span class="linenr">3: </span><span style="color: #81a2be;">OuterClass</span>.<span style="color: #81a2be;">StaticNestedClass</span> <span style="color: #f0c674;">nestedObject</span> =
<span class="linenr">4: </span>     <span style="color: #b5bd68;">new</span> <span style="color: #81a2be;">OuterClass</span>.<span style="color: #81a2be;">StaticNestedClass</span>();
</pre>
</div>

<ul class="org-ul">
<li>非静态内部类
</li>
</ul>
<p>
非静态嵌套类的实例只能存在外围类的实例中，因此要实例化它，必须先有外围
类的实例
</p>
<div class="org-src-container">

<pre class="src src-java"><span class="linenr">1: </span><span style="color: #81a2be;">OuterClass</span> <span style="color: #f0c674;">outerObject</span> = <span style="color: #b5bd68;">new</span> <span style="color: #81a2be;">OuterClass</span>();
<span class="linenr">2: </span><span style="color: #81a2be;">OuterClass</span>.<span style="color: #81a2be;">InnerClass</span> <span style="color: #f0c674;">innerObject</span> = outerObject.<span style="color: #b5bd68;">new</span> <span style="color: #81a2be;">InnerClass</span>();
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">匿名内部类</h2>
<div class="outline-text-2" id="text-2">
<p>
Anonymous Inner Class的名字理解，创建一个类来实现一个接口时，如果这个
类为top-level类，那么这个类肯定有名字，但是如果在一个类的内部，创建一
个实现接口的类或继承类，则可以不给类起名字，那就是匿名的。另外，匿名内部类肯定
是实现某一接口的类或继承某一父类的类。
</p>
<ul class="org-ul">
<li>示例一 实现接口的匿名类
</li>
</ul>
<div class="org-src-container">

<pre class="src src-java"><span class="linenr"> 1: </span><span style="color: #b5bd68;">public</span> <span style="color: #b5bd68;">interface</span> <span style="color: #81a2be;">Contents</span> {
<span class="linenr"> 2: </span>    <span style="color: #b5bd68;">public</span> <span style="color: #81a2be;">int</span> <span style="color: #de935f;">value</span>();
<span class="linenr"> 3: </span>}
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span><span style="color: #b5bd68;">public</span> <span style="color: #b5bd68;">class</span> <span style="color: #81a2be;">Parcel7</span> { &#65288;ref:parcel7)
<span class="linenr"> 6: </span>    <span style="color: #b5bd68;">public</span> Contents contents() {
<span class="linenr"> 7: </span>        <span style="color: #b5bd68;">return</span> <span style="color: #b5bd68;">new</span> <span style="color: #81a2be;">Contents</span>(){
<span class="linenr"> 8: </span>            <span style="color: #b5bd68;">private</span> <span style="color: #81a2be;">int</span> <span style="color: #f0c674;">i</span> = 11;
<span class="linenr"> 9: </span>            <span style="color: #b5bd68;">public</span> <span style="color: #81a2be;">int</span> <span style="color: #de935f;">value</span>() {<span style="color: #b5bd68;">return</span> i;}
<span class="linenr">10: </span>        };
<span class="linenr">11: </span>    }
<span class="linenr">12: </span>
<span class="linenr">13: </span>    <span style="color: #b5bd68;">public</span> <span style="color: #b5bd68;">static</span> <span style="color: #81a2be;">void</span> <span style="color: #de935f;">main</span>(<span style="color: #81a2be;">String</span>[] <span style="color: #f0c674;">args</span>) {
<span class="linenr">14: </span>        <span style="color: #81a2be;">Parcel7</span> <span style="color: #f0c674;">p</span> = <span style="color: #b5bd68;">new</span> <span style="color: #81a2be;">Parcel7</span>();
<span class="linenr">15: </span>        <span style="color: #81a2be;">Contents</span> <span style="color: #f0c674;">c</span> = p.contents();
<span class="linenr">16: </span>    }
<span class="linenr">17: </span>}
</pre>
</div>
<p>
line <a href="#coderef-ref:parcel7"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ref:parcel7');" onmouseout="CodeHighlightOff(this, 'coderef-ref:parcel7');">nil</a> 的类定义等价于下面的代码：
</p>
<div class="org-src-container">

<pre class="src src-java"><span class="linenr"> 1: </span><span style="color: #b5bd68;">public</span> <span style="color: #b5bd68;">class</span> <span style="color: #81a2be;">Parcel7</span> { &#65288;ref:parcel7)
<span class="linenr"> 2: </span>    <span style="color: #b5bd68;">public</span> MyContents <span style="color: #b5bd68;">implements</span> <span style="color: #81a2be;">Contents</span> {
<span class="linenr"> 3: </span>            <span style="color: #b5bd68;">private</span> <span style="color: #81a2be;">int</span> <span style="color: #f0c674;">i</span> = 11;
<span class="linenr"> 4: </span>            <span style="color: #b5bd68;">public</span> <span style="color: #81a2be;">int</span> <span style="color: #f0c674;">value</span>() {<span style="color: #b5bd68;">return</span> i;}
<span class="linenr"> 5: </span>    }
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>    <span style="color: #b5bd68;">public</span> <span style="color: #81a2be;">Contents</span> <span style="color: #de935f;">contents</span>() { <span style="color: #b5bd68;">return</span> <span style="color: #b5bd68;">new</span> <span style="color: #81a2be;">MyContents</span>(); }
<span class="linenr"> 8: </span>    <span style="color: #b5bd68;">public</span> <span style="color: #b5bd68;">static</span> <span style="color: #81a2be;">void</span> <span style="color: #de935f;">main</span>(<span style="color: #81a2be;">String</span>[] <span style="color: #f0c674;">args</span>) {
<span class="linenr"> 9: </span>        <span style="color: #81a2be;">Parcel7</span> <span style="color: #f0c674;">p</span> = <span style="color: #b5bd68;">new</span> <span style="color: #81a2be;">Parcel7</span>();
<span class="linenr">10: </span>        <span style="color: #81a2be;">Contents</span> <span style="color: #f0c674;">c</span> = p.contents();
<span class="linenr">11: </span>    }
<span class="linenr">12: </span>}
</pre>
</div>

<ul class="org-ul">
<li>继承父类的匿名类
</li>
</ul>
<div class="org-src-container">

<pre class="src src-java"><span class="linenr"> 1: </span><span style="color: #b5bd68;">class</span> <span style="color: #81a2be;">Wrapping</span> {
<span class="linenr"> 2: </span>    <span style="color: #b5bd68;">public</span> <span style="color: #81a2be;">int</span> <span style="color: #f0c674;">i</span> = 11;
<span class="linenr"> 3: </span>    <span style="color: #b5bd68;">public</span> <span style="color: #de935f;">Wrapping</span>(<span style="color: #81a2be;">int</span> <span style="color: #f0c674;">x</span>) { i = x; }
<span id="coderef-parent" class="coderef-off"><span class="linenr"> 4: </span>    <span style="color: #b5bd68;">public</span> <span style="color: #81a2be;">int</span> <span style="color: #de935f;">value</span>() {<span style="color: #b5bd68;">return</span> i;} (parent)</span>
<span class="linenr"> 5: </span>}
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #b5bd68;">public</span> <span style="color: #b5bd68;">class</span> <span style="color: #81a2be;">Parcel8</span> {
<span class="linenr"> 8: </span>    <span style="color: #b5bd68;">public</span> <span style="color: #81a2be;">Wrapping</span> <span style="color: #de935f;">wrapping</span>(<span style="color: #81a2be;">int</span> <span style="color: #f0c674;">x</span>) {
<span class="linenr"> 9: </span>        <span style="color: #b5bd68;">return</span> <span style="color: #b5bd68;">new</span> <span style="color: #81a2be;">Wrapping</span>(x) {
<span class="linenr">10: </span>            <span style="color: #b5bd68;">public</span> <span style="color: #81a2be;">int</span> <span style="color: #de935f;">value</span>() {
<span id="coderef-children" class="coderef-off"><span class="linenr">11: </span>                <span style="color: #b5bd68;">return</span> <span style="color: #b5bd68;">super</span>.value() * 47; (children)</span>
<span class="linenr">12: </span>            }
<span class="linenr">13: </span>        };
<span class="linenr">14: </span>    }
<span class="linenr">15: </span>}
</pre>
</div>
<p>
line <a href="#coderef-ref:children"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ref:children');" onmouseout="CodeHighlightOff(this, 'coderef-ref:children');">nil</a> 的 super.value() 来自父类 line <a href="#coderef-ref:parent"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ref:parent');" onmouseout="CodeHighlightOff(this, 'coderef-ref:parent');">nil</a> 的
value()
</p>

<ul class="org-ul">
<li>为什么需要内部类
</li>
</ul>
<p>
最有说服力的理由： 每个内部类能独立地继承自一个实现。这样的话，内部类
不会受到外围类是否已经继承了一个实现的限制。(意味着给多重继承(multiple-inheritance)提供了可
能)
</p>
<div class="org-src-container">

<pre class="src src-java"><span class="linenr"> 1: </span><span style="color: #b5bd68;">class</span> <span style="color: #81a2be;">D</span> {}
<span class="linenr"> 2: </span><span style="color: #b5bd68;">abstract</span> <span style="color: #b5bd68;">class</span> <span style="color: #81a2be;">E</span> {}
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span><span style="color: #b5bd68;">class</span> <span style="color: #81a2be;">Z</span> <span style="color: #b5bd68;">extends</span> <span style="color: #81a2be;">D</span> {
<span class="linenr"> 5: </span>    <span style="color: #81a2be;">E</span> <span style="color: #de935f;">makeE</span>() { <span style="color: #b5bd68;">return</span> <span style="color: #b5bd68;">new</span> <span style="color: #81a2be;">E</span>() {};}
<span class="linenr"> 6: </span>}
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span><span style="color: #b5bd68;">public</span> <span style="color: #b5bd68;">class</span> <span style="color: #81a2be;">MultiImplementation</span> {
<span class="linenr"> 9: </span>    <span style="color: #b5bd68;">static</span> <span style="color: #81a2be;">void</span> <span style="color: #de935f;">takesD</span>(<span style="color: #81a2be;">D</span> <span style="color: #f0c674;">d</span>) {}
<span class="linenr">10: </span>    <span style="color: #b5bd68;">static</span> <span style="color: #81a2be;">void</span> <span style="color: #de935f;">takesE</span>(<span style="color: #81a2be;">E</span> <span style="color: #f0c674;">e</span>) {}
<span class="linenr">11: </span>    <span style="color: #b5bd68;">public</span> <span style="color: #b5bd68;">static</span> <span style="color: #81a2be;">void</span> <span style="color: #de935f;">main</span>(<span style="color: #81a2be;">String</span>[] <span style="color: #f0c674;">args</span>) {
<span class="linenr">12: </span>        <span style="color: #81a2be;">Z</span> <span style="color: #f0c674;">z</span> = <span style="color: #b5bd68;">new</span> <span style="color: #81a2be;">Z</span>();
<span class="linenr">13: </span>        takesD(z);
<span class="linenr">14: </span>        takesE(z.makeE());
<span class="linenr">15: </span>    }
<span class="linenr">16: </span>}
</pre>
</div>

<ul class="org-ul">
<li>内部类与闭包和回调
</li>
</ul>
<p>
闭包，也称词法闭包或函数闭包，是包含引用环境的一个函数或对一个函数的引
用，其中引用环境为一个表，它存储着那个函数的每个非本地变量。不像普通的
函数指针，一个闭包(即使在它的临时词法范围之外被调用)允许访问那些非本地
变量。一方面，对于特定的编程语言来说，支持闭包意味着函数成为该编程语言
的一等公民，可以构建高阶函数；另一方面，对闭包的理解可以帮助构建更符合
面向对象思想的程序，如信息隐藏。
</p>

<p>
对Java而言，内部类可以看成是一个面向对象(object-oriented)闭包，因为它
不仅包含来自外部类对象的所有信息(指它被创建的程序范围)，而且它自动地持
有一份指向外部类对象的引用，在那里，它有权控制所有成员，private成员也
不例外。
</p>

<p>
在Java中，是否要包含指针机制，最强烈的争议之一就是为了实现callback。
有了回调机制，某一对象被给予一些信息(是指将回调对象作为参数存储起来)，
这些信息允许该对象回调原始对象<sup><a id="fnr.2" name="fnr.2" class="footref" href="#fn.2">2</a></sup><sup>, </sup><sup><a id="fnr.3" name="fnr.3" class="footref" href="#fn.3">3</a></sup>(具体而言，是原始对象的方法)。
最后放弃实现指针，因为Java中有接口和内部类，足以更好的实现callback。
</p>
<div class="org-src-container">

<pre class="src src-java"><span class="linenr"> 1: </span><span style="color: #b5bd68;">interface</span> <span style="color: #81a2be;">Incrementable</span> {
<span class="linenr"> 2: </span>    <span style="color: #81a2be;">void</span> <span style="color: #de935f;">increment</span>();
<span class="linenr"> 3: </span>}
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span><span style="color: #b5bd68;">class</span> <span style="color: #81a2be;">Callee1</span> <span style="color: #b5bd68;">implements</span> <span style="color: #81a2be;">Incrementable</span> {
<span class="linenr"> 6: </span>    <span style="color: #b5bd68;">private</span> <span style="color: #81a2be;">int</span> <span style="color: #f0c674;">i</span> = 0;
<span class="linenr"> 7: </span>    <span style="color: #b5bd68;">public</span> <span style="color: #81a2be;">void</span> <span style="color: #de935f;">increment</span>() {
<span class="linenr"> 8: </span>        i++;
<span class="linenr"> 9: </span>        System.out.println(i);
<span class="linenr">10: </span>    }
<span class="linenr">11: </span>}
<span class="linenr">12: </span>
<span class="linenr">13: </span><span style="color: #b5bd68;">class</span> <span style="color: #81a2be;">MyIncrement</span> {
<span class="linenr">14: </span>    <span style="color: #b5bd68;">public</span> <span style="color: #81a2be;">void</span> <span style="color: #de935f;">increment</span>() { System.out.println(<span style="color: #8abeb7;">"Other operation"</span>);}
<span class="linenr">15: </span>    <span style="color: #b5bd68;">static</span> <span style="color: #81a2be;">void</span> <span style="color: #de935f;">f</span>(<span style="color: #81a2be;">MyIncrement</span> <span style="color: #f0c674;">mi</span>) { mi.increment(); }
<span class="linenr">16: </span>}
<span class="linenr">17: </span>
<span class="linenr">18: </span><span style="color: #b5bd68;">class</span> <span style="color: #81a2be;">Callee2</span> <span style="color: #b5bd68;">extends</span> <span style="color: #81a2be;">MyIncrement</span> {
<span class="linenr">19: </span>    <span style="color: #b5bd68;">private</span> <span style="color: #81a2be;">int</span> <span style="color: #f0c674;">i</span> = 0;
<span class="linenr">20: </span>    <span style="color: #b5bd68;">public</span> <span style="color: #81a2be;">void</span> <span style="color: #de935f;">increment</span>() {
<span class="linenr">21: </span>        <span style="color: #b5bd68;">super</span>.increment();
<span class="linenr">22: </span>        i++;
<span class="linenr">23: </span>        System.out.println(i);
<span class="linenr">24: </span>    }
<span class="linenr">25: </span>    <span style="color: #b5bd68;">private</span> <span style="color: #b5bd68;">class</span> <span style="color: #81a2be;">Closure</span> <span style="color: #b5bd68;">implements</span> <span style="color: #81a2be;">Incrementable</span> {
<span class="linenr">26: </span>        <span style="color: #b5bd68;">public</span> <span style="color: #81a2be;">void</span> <span style="color: #de935f;">increment</span>() {
<span class="linenr">27: </span>            Callee2.<span style="color: #b5bd68;">this</span>.increment();
<span class="linenr">28: </span>        }
<span class="linenr">29: </span>    }
<span class="linenr">30: </span>
<span class="linenr">31: </span>    <span style="color: #81a2be;">Incrementable</span> <span style="color: #de935f;">getCallbackReference</span>() {
<span class="linenr">32: </span>        <span style="color: #b5bd68;">return</span> <span style="color: #b5bd68;">new</span> <span style="color: #81a2be;">Closure</span>();
<span class="linenr">33: </span>    }
<span class="linenr">34: </span>}
<span class="linenr">35: </span>
<span class="linenr">36: </span><span style="color: #b5bd68;">class</span> <span style="color: #81a2be;">Caller</span> {
<span class="linenr">37: </span>    <span style="color: #b5bd68;">private</span> <span style="color: #81a2be;">Incrementable</span> <span style="color: #f0c674;">callbackReference</span>;
<span class="linenr">38: </span>    <span style="color: #de935f;">Caller</span>( <span style="color: #81a2be;">Incrementable</span> <span style="color: #f0c674;">cbh</span>) { callbackReference = cbh; }
<span class="linenr">39: </span>    <span style="color: #81a2be;">void</span> <span style="color: #de935f;">go</span>() { callbackReference.increment();}
<span class="linenr">40: </span>}
<span class="linenr">41: </span>
<span class="linenr">42: </span><span style="color: #b5bd68;">public</span> <span style="color: #b5bd68;">class</span> <span style="color: #81a2be;">Callbacks</span> {
<span class="linenr">43: </span>    <span style="color: #b5bd68;">public</span> <span style="color: #b5bd68;">static</span> <span style="color: #81a2be;">void</span> <span style="color: #de935f;">main</span>(<span style="color: #81a2be;">String</span>[] <span style="color: #f0c674;">args</span>) {
<span class="linenr">44: </span>        <span style="color: #81a2be;">Callee1</span> <span style="color: #f0c674;">c1</span> = <span style="color: #b5bd68;">new</span> <span style="color: #81a2be;">Callee1</span>();
<span class="linenr">45: </span>        <span style="color: #81a2be;">Callee2</span> <span style="color: #f0c674;">c2</span> = <span style="color: #b5bd68;">new</span> <span style="color: #81a2be;">Callee2</span>();
<span class="linenr">46: </span>        MyIncrement.f(c2);
<span class="linenr">47: </span>        <span style="color: #81a2be;">Caller</span> <span style="color: #f0c674;">caller1</span> = <span style="color: #b5bd68;">new</span> <span style="color: #81a2be;">Caller</span>(c1);
<span class="linenr">48: </span>        <span style="color: #81a2be;">Caller</span> <span style="color: #f0c674;">caller2</span> = <span style="color: #b5bd68;">new</span> <span style="color: #81a2be;">Caller</span>(c2.getCallbackReference());
<span class="linenr">49: </span>        caller1.go();
<span class="linenr">50: </span>        caller1.go();
<span class="linenr">51: </span>        caller2.go();
<span class="linenr">52: </span>        caller2.go();
<span class="linenr">53: </span>    }
<span class="linenr">54: </span>}
</pre>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">
<a href="http://docs.oracle.com/javase/tutorial/java/javaOO/nested.html">http://docs.oracle.com/javase/tutorial/java/javaOO/nested.html</a>
</p></div>

<div class="footdef"><sup><a id="fn.2" name="fn.2" class="footnum" href="#fnr.2">2</a></sup> <p class="footpara">
感觉wikipedia上的callback说的更清晰： a callback is a piece of
executable code that is passed as an argument to other code, which is
expected to call back (execute) the argument at some convenient time.
一个callback是一段执行代码，给作为参数传递给其它代码，期望其它代码在将
来某一时刻回调(执行)这段代码。而为什么用callback呢，因为先要将callback
函数传递给调用者，后来再有调用者callback回来。
</p></div>

<div class="footdef"><sup><a id="fn.3" name="fn.3" class="footnum" href="#fnr.3">3</a></sup> <p class="footpara">
某一对象是caller，原始对象是callback
</p>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">访问和实例化</a></li>
<li><a href="#sec-2">匿名内部类</a></li>
</ul>
</div>
</div></div>


</div>
</div>
