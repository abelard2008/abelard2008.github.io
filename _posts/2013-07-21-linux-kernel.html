---
category: computer science and enginneering
layout: post
title: "Change Memory Allocation During the Early Stage of Linux Initalization for Crash  Data"
tags: ["Linux", "Linux Kernel", "Memory Management"]
---

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">内核初始化阶段分配内存</h2>
<div class="outline-text-2" id="text-1">
<p>
内核启动初期，并不能使用像kmallo之类的函数，因为这时候slab还没有开始工作，linux使用了一种称为early reserve的方式，以前使用成为BOOTMEM的分配方式，现在不用BOOTMEM了，但是很多函数还是沿用了老的名称。主要的有如下几个函数：
</p>

<ul class="org-ul">
<li>__alloc_memory_core_early(int nid, u64 size, u64 align,u64 goal,u64 limit)
</li>

<li>alloc_bootmem(int size)
</li>
</ul>
<p>
上面两个函数， <b>alloc_bootmem</b> 会调用第一个函数来完成， <b>__alloc_memory_core_early</b> 的goal为想要分配的起始物理地址，因此所有 <b>alloc_bootmem</b> 都会使用*_pa(MAX_DMA_ADDRESS))*生成一个固定的物理地址作
为goal，如果这个地址没有被分作其他用途，将得到一个goal开始的空间，否则，将在内存空间中找到一个符合size要求的内存块(并一个goal的地址)。如果分配成功，都会返回一个线性地址。如果失败，也不会影响什么。
</p>

<ul class="org-ul">
<li>void __init reserve_early(u64 start, u64 end, char *name)
</li>
</ul>

<p>
该函数没有返回值，所传入的起始和结束地址为物理地址，如果分配失败，就会宕机，因此它用于在启动最早期分配内存，并且确信分配肯定成功，如第一个使用者为*x86_64_start_reservations*函数(追查下去，该函数由汇编调用)。 使用该函数的主要为装载内核代码，BIOS相关、SMP相关等。
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">如何保证分配大块内存的起始地址不被分配函数修改</h2>
<div class="outline-text-2" id="text-2">
<p>
举例，在一个4G内linux系统中，为某个模块分配从1G位置开始的2G内存。希望1G的位置固定不变。
</p>

<p>
如果在init/main.c的start_kernel中，如*build_all_zonelists()*之后，插入上面的函数来分配空间，即使输入起始地址为1G(0x40000000)，最后返回的结果是起始地址发生了变化。
</p>

<p>
从kernel/early_res.c的*subtract_early_res*打印的所有启动早期分配的空间情况看，应该将要用于特定模块的大块内存尽早分配，以免被内核分配给其它功能模块。
</p>

<p>
但是考虑到灵活性，如只想给内核留下1G空间，剩下的内存都用于这个模块，因此需要获取内存大小的信息，linux在使用 <b>arch/x86/kernel/setup.c</b> 的 <b>setup_arch()</b> 函数中调用 <b>mtrr_bp_init()</b> 完成了内存大小的读取(具体通过e820功能模块)，并且将内存大小值存入 <b>range_sums</b> ，该变量定义为文件 <b>cleanup.c</b> 中的静态变量，为了文件外访问，改为全局变量，那样在 <b>setup_arch</b> 里就可以使用它来分析具体分配给这个特定模块的空间大小了，即在调用了 <b>mtrr_bp_init()</b> 之后，调用 <b>reserve_early</b> 函数：
</p>
<div class="org-src-container">

<pre class="src src-c">reserve_early(0x40000000, 0xC0000000, <span style="color: #8abeb7;">"TP_SCST_RAID"</span>);
</pre>
</div>
<p>
当然，分配出去的2G空间，在linux启动后，使用*free*命令就会发现，分出去的2G不会出现在空闲空间中。
</p>
</div>
</div>
