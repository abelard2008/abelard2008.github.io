---
category: computer science and enginneering
layout: post
title: "Postgres Source Code and Theory"
description: "study database through postgres"
tags: ["database",tools]
---
{% include JB/setup %}

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Replacement Selection</h2>
<div class="outline-text-2" id="text-1">
<p>
ExecSort() extract all tuples 
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #b5bd68;">for</span> (;;)
{
        slot = ExecProcNode(outerNode);

        <span style="color: #b5bd68;">if</span> (TupIsNull(slot))
                <span style="color: #b5bd68;">break</span>;

        tuplesort_puttupleslot(tuplesortstate, slot);
}
</pre>
</div>

<p>
tuplesort_puttupleslot() -&gt; &#x2026; -&gt; puttuple_common(), at this time,
the state-&gt;status is TSS_INITIAL, when state-&gt;memtupcount is less than
state-&gt;memtupsize, where memtupsize is 8192 (equal to BLCKSZ).
</p>
<div class="org-src-container">

<pre class="src src-c">state-&gt;memtuples[state-&gt;memtupcount++] = *tuple;
</pre>
</div>

<p>
when memtupcount is larger than 8192, inittapes() will be called and
use dumptuples() to insert state-&gt;memtuples<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup> into relative temp
files (called run), and the new tuple from ExecProcNode(outerNode)
will insert state-&gt;memtuples.
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">planner</h2>
<div class="outline-text-2" id="text-2">
<p>
select * from customer:
planner()&lt;-pg_plan_query()&lt;-pg_plan_queries()&lt;-exec_simple_query()
</p>

<p>
explain select * from customer: planner()&lt;-pg_plan_query()&lt;-ExplainOneQuery()&lt;-ExplainQuery()
</p>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">sql</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">generate random number</h3>
<div class="outline-text-3" id="text-3-1">
<div class="org-src-container">

<pre class="src src-sql">tuplesort=# <span style="color: #b5bd68;">select</span> random();
      random       
<span style="color: #969896; font-style: italic;">-------------------</span>
 0.862202602438629
(1 <span style="color: #81a2be;">row</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">create function for arbitrary date in a specified rang</h3>
<div class="outline-text-3" id="text-3-2">
<div class="org-src-container">

<pre class="src src-sql">tuplesort=# <span style="color: #b5bd68;">create</span> <span style="color: #b5bd68;">or</span> replace <span style="color: #b5bd68;">function</span> generate_dates(
dt1 <span style="color: #81a2be;">date</span>,
dt2 <span style="color: #81a2be;">date</span>,
n <span style="color: #81a2be;">int</span>) <span style="color: #b5bd68;">returns</span> setof <span style="color: #81a2be;">date</span> <span style="color: #b5bd68;">as</span> 
$$
<span style="color: #b5bd68;">select</span> $1 + $3;
$$ <span style="color: #b5bd68;">language</span> <span style="color: #8abeb7;">'sql'</span> immutable;

tuplesort=# <span style="color: #b5bd68;">select</span> generate_dates(<span style="color: #8abeb7;">'2009-01-01'</span>,<span style="color: #8abeb7;">'2009-12-31'</span>,<span style="color: #b294bb;">mod</span>((random()*10000)::<span style="color: #81a2be;">integer</span>,365));
 generate_dates 
<span style="color: #969896; font-style: italic;">----------------</span>
 2009-11-13
(1 <span style="color: #81a2be;">row</span>)

tuplesort=# <span style="color: #b5bd68;">select</span> generate_dates(<span style="color: #8abeb7;">'2009-01-01'</span>,<span style="color: #8abeb7;">'2009-12-31'</span>,<span style="color: #b294bb;">mod</span>((random()*10000)::<span style="color: #81a2be;">integer</span>,365));
 generate_dates 
<span style="color: #969896; font-style: italic;">----------------</span>
 2009-09-28
(1 <span style="color: #81a2be;">row</span>)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">parser</h2>
<div class="outline-text-2" id="text-4">
<p>
the parser include two phases: parser and transfromation.
</p>

<p>
the parser phase mainly creates a specified called raw
parse tree,  which is a linked list of parse nodes. there are
several kinds of nodes, as defined in parsenodes.h, such as SelectStmt,
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b5bd68;">typedef</span> <span style="color: #b5bd68;">struct</span> <span style="color: #81a2be;">SelectStmt</span>
{
        <span style="color: #81a2be;">NodeTag</span>         <span style="color: #f0c674;">type</span>;

        <span style="color: #969896; font-style: italic;">/*</span>
<span style="color: #969896; font-style: italic;">         * These fields are used only in "leaf" SelectStmts.</span>
<span style="color: #969896; font-style: italic;">         </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">List</span>       *<span style="color: #f0c674;">distinctClause</span>; <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">NULL, list of DISTINCT ON exprs, or</span>
<span style="color: #969896; font-style: italic;">                                                                 * lcons(NIL,NIL) for all (SELECT DISTINCT) </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">IntoClause</span> *<span style="color: #f0c674;">intoClause</span>;         <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">target for SELECT INTO / CREATE TABLE AS </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">List</span>       *<span style="color: #f0c674;">targetList</span>;         <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">the target list (of ResTarget) </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">List</span>       *<span style="color: #f0c674;">fromClause</span>;         <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">the FROM clause </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">Node</span>       *<span style="color: #f0c674;">whereClause</span>;        <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">WHERE qualification </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">List</span>       *<span style="color: #f0c674;">groupClause</span>;        <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">GROUP BY clauses </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">Node</span>       *<span style="color: #f0c674;">havingClause</span>;       <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">HAVING conditional-expression </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">List</span>       *<span style="color: #f0c674;">windowClause</span>;       <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">WINDOW window_name AS (...), ... </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">WithClause</span> *<span style="color: #f0c674;">withClause</span>;         <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">WITH clause </span><span style="color: #969896; font-style: italic;">*/</span>
      ...
}
</pre>
</div>
<p>
the first member of these classes of structures all is NodeTag, every
query will create a node with some fixed members, in above
SelectStmt, which has intClause, targetList, etc,. so in gram.y, for
every kind of query, it creates a root node for special query:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #81a2be;">simple_select</span>:
                        SELECT opt_distinct target_list
                        into_clause from_clause where_clause
                        group_clause <span style="color: #81a2be;">having_clause</span> <span style="color: #f0c674;">window_clause</span>
                                {
                                        <span style="color: #81a2be;">SelectStmt</span> *<span style="color: #f0c674;">n</span> = makeNode(SelectStmt);
                                        n-&gt;distinctClause = $2;
                                        n-&gt;targetList = $3;
                                        n-&gt;intoClause = $4;
                                        n-&gt;fromClause = $5;
...
</pre>
</div>
<p>
and the definition for makeNode in nodes.h
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b5bd68;">extern</span> PGDLLIMPORT <span style="color: #81a2be;">Node</span> *<span style="color: #f0c674;">newNodeMacroHolder</span>;
<span style="color: #b294bb;">#define</span> <span style="color: #de935f;">newNode</span>(<span style="color: #f0c674;">size</span>, <span style="color: #f0c674;">tag</span>) \
( \
        AssertMacro((size) &gt;= <span style="color: #b5bd68;">sizeof</span>(Node)),            <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">need the tag, at least </span><span style="color: #969896; font-style: italic;">*/</span> \
        newNodeMacroHolder = (<span style="color: #81a2be;">Node</span> *) palloc0fast(size), \
        newNodeMacroHolder-&gt;type = (tag), \
        newNodeMacroHolder \
)
<span style="color: #b294bb;">#endif</span>   <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">__GNUC__ </span><span style="color: #969896; font-style: italic;">*/</span>


<span style="color: #b294bb;">#define</span> <span style="color: #de935f;">makeNode</span>(<span style="color: #f0c674;">_type_</span>)                ((<span style="color: #81a2be;">_type_</span> *) newNode(<span style="color: #b5bd68;">sizeof</span>(_type_),T_##_type_))
</pre>
</div>
<p>
T_##_type_ should be paid attention, because it will be assigned
to the first member of the root node, such as SelectStmt.type, after
that, many task will be completed by the type.  
</p>

<p>
in analysis phase, the previous raw parse tree will be sematic
analysis.
</p>
<div class="org-src-container">

<pre class="src src-c">pg_analyze_and_rewrite(Node *parsetree, <span style="color: #b5bd68;">const</span> <span style="color: #81a2be;">char</span> *<span style="color: #f0c674;">query_string</span>,...) 
-&gt; parse_analyze(parsetree, query_string, paramTypes, numParams)
-&gt; query = transformStmt(pstate, parseTree);
-&gt; transformSelectStmt(ParseState *pstate, SelectStmt *stmt)
</pre>
</div>

<p>
after parse_analyze(), we will get a query (type: Query)
</p>

<p>
in transformStmt():
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #81a2be;">Query</span> *
<span style="color: #de935f;">transformStmt</span>(<span style="color: #81a2be;">ParseState</span> *<span style="color: #f0c674;">pstate</span>, <span style="color: #81a2be;">Node</span> *<span style="color: #f0c674;">parseTree</span>)
{
        <span style="color: #81a2be;">Query</span>      *<span style="color: #f0c674;">result</span>;

        <span style="color: #b5bd68;">switch</span> (nodeTag(parseTree))
        {
                <span style="color: #b5bd68;">case</span> T_SelectStmt:
                        {
                                <span style="color: #81a2be;">SelectStmt</span> *<span style="color: #f0c674;">n</span> = (<span style="color: #81a2be;">SelectStmt</span> *) parseTree;

                                <span style="color: #b5bd68;">if</span> (n-&gt;valuesLists)
                                        result = transformValuesClause(pstate, n);
                                <span style="color: #b5bd68;">else</span> <span style="color: #b5bd68;">if</span> (n-&gt;op == SETOP_NONE)
                                        result = transformSelectStmt(pstate, n);
                                <span style="color: #b5bd68;">else</span>
                                        result = transformSetOperationStmt(pstate, n);
                        }
                        <span style="color: #b5bd68;">break</span>;
</pre>
</div>

<p>
in transformSelectStmt():
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b5bd68;">static</span> <span style="color: #81a2be;">Query</span> *
<span style="color: #de935f;">transformSelectStmt</span>(<span style="color: #81a2be;">ParseState</span> *<span style="color: #f0c674;">pstate</span>, <span style="color: #81a2be;">SelectStmt</span> *<span style="color: #f0c674;">stmt</span>)
{
        <span style="color: #81a2be;">Query</span>      *<span style="color: #f0c674;">qry</span> = makeNode(Query);
</pre>
</div>
<p>
from the first statement, the node type was transformed from
SelectStmt to Query.
</p>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">system catalog</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">pg_opclass</h3>
<div class="outline-text-3" id="text-5-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Column</th>
<th scope="col" class="left">Type</th>
<th scope="col" class="left">Modifiers</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">opcmethod</td>
<td class="left">oid</td>
<td class="left">not null</td>
</tr>

<tr>
<td class="left">opcname</td>
<td class="left">name</td>
<td class="left">not null</td>
</tr>

<tr>
<td class="left">opcnamespace</td>
<td class="left">oid</td>
<td class="left">not null</td>
</tr>

<tr>
<td class="left">opcowner</td>
<td class="left">oid</td>
<td class="left">not null</td>
</tr>

<tr>
<td class="left">opcfamily</td>
<td class="left">oid</td>
<td class="left">not null</td>
</tr>

<tr>
<td class="left">opcintype</td>
<td class="left">oid</td>
<td class="left">not null</td>
</tr>

<tr>
<td class="left">opcdefault</td>
<td class="left">boolean</td>
<td class="left">not null</td>
</tr>

<tr>
<td class="left">opckeytype</td>
<td class="left">oid</td>
<td class="left">not null</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">pg_am</h3>
<div class="outline-text-3" id="text-5-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Column</th>
<th scope="col" class="left">Type</th>
<th scope="col" class="left">Modifiers</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">amname</td>
<td class="left">name</td>
<td class="left">not null</td>
</tr>

<tr>
<td class="left">amstrategies</td>
<td class="left">smallint</td>
<td class="left">not null</td>
</tr>

<tr>
<td class="left">amsupport</td>
<td class="left">smallint</td>
<td class="left">not null</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3">pg_amop</h3>
<div class="outline-text-3" id="text-5-3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Column</th>
<th scope="col" class="left">Type</th>
<th scope="col" class="left">Modifiers</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">amopfamily</td>
<td class="left">oid</td>
<td class="left">not null</td>
</tr>

<tr>
<td class="left">amoplefttype</td>
<td class="left">oid</td>
<td class="left">not null</td>
</tr>

<tr>
<td class="left">amoprighttype</td>
<td class="left">oid</td>
<td class="left">not null</td>
</tr>

<tr>
<td class="left">amopstrategy</td>
<td class="left">smallint</td>
<td class="left">not null</td>
</tr>

<tr>
<td class="left">amopopr</td>
<td class="left">oid</td>
<td class="left">not null</td>
</tr>

<tr>
<td class="left">amopmethod</td>
<td class="left">oid</td>
<td class="left">not null</td>
</tr>
</tbody>
</table>
</div>

<ul class="org-ul"><li>pg_opfamily<br  /><div class="outline-text-4" id="text-5-3-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Column</th>
<th scope="col" class="left">Type</th>
<th scope="col" class="left">Modifiers</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">opfmethod</td>
<td class="left">oid</td>
<td class="left">not null</td>
</tr>

<tr>
<td class="left">opfname</td>
<td class="left">name</td>
<td class="left">not null</td>
</tr>

<tr>
<td class="left">opfnamespace</td>
<td class="left">oid</td>
<td class="left">not null</td>
</tr>

<tr>
<td class="left">opfowner</td>
<td class="left">oid</td>
<td class="left">not null</td>
</tr>
</tbody>
</table>

<p>
NOTE: opcmethod, amopmethod and opfmethod are the same value as
pg_am's oid, so that the following query is right:
</p>

<div class="org-src-container">

<pre class="src src-sql"><span style="color: #b5bd68;">SELECT</span> am.amname <span style="color: #b5bd68;">AS</span> index_method,
       opc.opcname <span style="color: #b5bd68;">AS</span> opclass_name
    <span style="color: #b5bd68;">FROM</span> pg_am am, pg_opclass opc
    <span style="color: #b5bd68;">WHERE</span> opc.opcmethod = am.oid
    <span style="color: #b5bd68;">ORDER</span> <span style="color: #b5bd68;">BY</span> index_method, opclass_name;

<span style="color: #b5bd68;">SELECT</span> am.amname <span style="color: #b5bd68;">AS</span> index_method,
       opf.opfname <span style="color: #b5bd68;">AS</span> opfamily_name,
       amop.amopopr::regoperator <span style="color: #b5bd68;">AS</span> opfamily_operator
    <span style="color: #b5bd68;">FROM</span> pg_am am, pg_opfamily opf, pg_amop amop
    <span style="color: #b5bd68;">WHERE</span> opf.opfmethod = am.oid <span style="color: #b5bd68;">AND</span>
          amop.amopfamily = opf.oid
    <span style="color: #b5bd68;">ORDER</span> <span style="color: #b5bd68;">BY</span> index_method, opfamily_name, opfamily_operator;
</pre>
</div>

<p>
also, amopfamily in pg_amop is the same value as pg_opfamily's oid.
</p>
</div>
</li></ul>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">operator classes explained<sup><a id="fnr.2" name="fnr.2" class="footref" href="#fn.2">2</a></sup></h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1">what is an operator class?</h3>
<div class="outline-text-3" id="text-6-1">
<p>
in PostgreSQL an index is not a hardwired thing,capable of following
just one strategy.
</p>

<p>
Asume that two values stored in a database:
</p>

<div class="org-src-container">

<pre class="src src-sql"><span style="color: #b5bd68;">CREATE</span> <span style="color: #b5bd68;">TABLE</span> <span style="color: #de935f;">t_sva</span> (sva text);

<span style="color: #b5bd68;">INSERT</span> <span style="color: #b5bd68;">INTO</span> t_sva <span style="color: #b5bd68;">VALUES</span> (<span style="color: #8abeb7;">'1118090878'</span>);
<span style="color: #b5bd68;">INSERT</span> <span style="color: #b5bd68;">INTO</span> t_sva <span style="color: #b5bd68;">VALUES</span> (<span style="color: #8abeb7;">'2345010477'</span>);
</pre>
</div>

<p>
1118090878 is Austrian social security number, 09 = day of month, 08 = month, 78 = year, 1118 = a sequential number,
so that 1118090878 is actually after 2345010477.
</p>

<p>
how to implement this strange sort, we need our own handcrafted
indexing strategy using PostgreSQL's operator class.
</p>
</div>
</div>

<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2">how it works</h3>
<div class="outline-text-3" id="text-6-2">
<div class="org-src-container">

<pre class="src src-sql"><span style="color: #b5bd68;">CREATE</span> <span style="color: #b5bd68;">OR</span> REPLACE <span style="color: #b5bd68;">FUNCTION</span> <span style="color: #de935f;">normalize_si</span>(text)

<span style="color: #b5bd68;">RETURNS</span> text <span style="color: #b5bd68;">AS</span> $$

        <span style="color: #b5bd68;">BEGIN</span>

        <span style="color: #b5bd68;">RETURN</span> <span style="color: #b294bb;">substring</span>($1, 9, 2) ||

                <span style="color: #b294bb;">substring</span>($1, 7, 2) || <span style="color: #b294bb;">substring</span>($1, 5, 2) || <span style="color: #b294bb;">substring</span>($1, 1, 4);

        <span style="color: #b5bd68;">END</span>; $$

<span style="color: #b5bd68;">LANGUAGE</span> <span style="color: #8abeb7;">'plpgsql'</span> IMMUTABLE;

<span style="color: #b5bd68;">SELECT</span> normalize_si(<span style="color: #8abeb7;">'1118090878'</span>);

normalize_si

<span style="color: #969896; font-style: italic;">--------------</span>

7808091118

(1 <span style="color: #81a2be;">row</span>)

<span style="color: #b5bd68;">CREATE</span> <span style="color: #b5bd68;">OR</span> REPLACE <span style="color: #b5bd68;">FUNCTION</span> <span style="color: #de935f;">si_lt</span>(text, text)

        <span style="color: #b5bd68;">RETURNS</span> <span style="color: #81a2be;">boolean</span> <span style="color: #b5bd68;">AS</span>

$$

        <span style="color: #b5bd68;">BEGIN</span>

                <span style="color: #b5bd68;">RETURN</span> normalize_si($1) &lt; normalize_si($2);

        <span style="color: #b5bd68;">END</span>;

$$ <span style="color: #b5bd68;">LANGUAGE</span> <span style="color: #8abeb7;">'plpgsql'</span> IMMUTABLE;

<span style="color: #969896; font-style: italic;">-- lower equals</span>

<span style="color: #b5bd68;">CREATE</span> <span style="color: #b5bd68;">OR</span> REPLACE <span style="color: #b5bd68;">FUNCTION</span> <span style="color: #de935f;">si_le</span>(text, text)

        <span style="color: #b5bd68;">RETURNS</span> <span style="color: #81a2be;">boolean</span> <span style="color: #b5bd68;">AS</span>

$$

        <span style="color: #b5bd68;">BEGIN</span>

                <span style="color: #b5bd68;">RETURN</span> normalize_si($1) &lt;= normalize_si($2);

        <span style="color: #b5bd68;">END</span>;

$$ <span style="color: #b5bd68;">LANGUAGE</span> <span style="color: #8abeb7;">'plpgsql'</span> IMMUTABLE;

<span style="color: #969896; font-style: italic;">-- greater equal</span>

<span style="color: #b5bd68;">CREATE</span> <span style="color: #b5bd68;">OR</span> REPLACE <span style="color: #b5bd68;">FUNCTION</span> <span style="color: #de935f;">si_ge</span>(text, text)

<span style="color: #b5bd68;">RETURNS</span> <span style="color: #81a2be;">boolean</span> <span style="color: #b5bd68;">AS</span>

$$

<span style="color: #b5bd68;">BEGIN</span>

<span style="color: #b5bd68;">RETURN</span> normalize_si($1) &gt;= normalize_si($2);

<span style="color: #b5bd68;">END</span>;

$$ <span style="color: #b5bd68;">LANGUAGE</span> <span style="color: #8abeb7;">'plpgsql'</span> IMMUTABLE;

<span style="color: #969896; font-style: italic;">-- greater</span>

<span style="color: #b5bd68;">CREATE</span> <span style="color: #b5bd68;">OR</span> REPLACE <span style="color: #b5bd68;">FUNCTION</span> <span style="color: #de935f;">si_gt</span>(text, text)

<span style="color: #b5bd68;">RETURNS</span> <span style="color: #81a2be;">boolean</span> <span style="color: #b5bd68;">AS</span>

$$

<span style="color: #b5bd68;">BEGIN</span>

<span style="color: #b5bd68;">RETURN</span> normalize_si($1) &gt; normalize_si($2);

<span style="color: #b5bd68;">END</span>;

$$ <span style="color: #b5bd68;">LANGUAGE</span> <span style="color: #8abeb7;">'plpgsql'</span> IMMUTABLE;
</pre>
</div>

<p>
in PostgreSQL every operator is simply based on a stored procedure.
</p>

<div class="org-src-container">

<pre class="src src-sql"><span style="color: #969896; font-style: italic;">-- define operators</span>

<span style="color: #b5bd68;">CREATE</span> OPERATOR &lt;# ( <span style="color: #b5bd68;">PROCEDURE</span>=si_lt,

                        LEFTARG=text,

                        RIGHTARG=text);

<span style="color: #b5bd68;">CREATE</span> OPERATOR &lt;=# ( <span style="color: #b5bd68;">PROCEDURE</span>=si_le,

                        LEFTARG=text,

                        RIGHTARG=text);

<span style="color: #b5bd68;">CREATE</span> OPERATOR &gt;=# ( <span style="color: #b5bd68;">PROCEDURE</span>=si_ge,

                        LEFTARG=text,

                        RIGHTARG=text);

<span style="color: #b5bd68;">CREATE</span> OPERATOR &gt;# ( <span style="color: #b5bd68;">PROCEDURE</span>=si_gt,

                        LEFTARG=text,

                        RIGHTARG=text);

tuplesort=# <span style="color: #b5bd68;">select</span> * <span style="color: #b5bd68;">from</span> t_sva <span style="color: #b5bd68;">order</span> <span style="color: #b5bd68;">by</span> sva  <span style="color: #b5bd68;">using</span> &gt;;
    sva     
<span style="color: #969896; font-style: italic;">------------</span>
 2345010477
 1118090878
(2 <span style="color: #b5bd68;">rows</span>)

tuplesort=# <span style="color: #b5bd68;">select</span> * <span style="color: #b5bd68;">from</span> t_sva <span style="color: #b5bd68;">order</span> <span style="color: #b5bd68;">by</span> sva  <span style="color: #b5bd68;">using</span> &gt;#;
    sva     
<span style="color: #969896; font-style: italic;">------------</span>
 1118090878
 2345010477
(2 <span style="color: #b5bd68;">rows</span>)
</pre>
</div>

<p>
If you want to crate an operator you must tell PostgreSQL which
function to call.
</p>
</div>
</div>

<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3">support functions</h3>
<div class="outline-text-3" id="text-6-3">
<p>
Before an index shows to handle a new strategy we have to define some
support functions.
</p>

<div class="org-src-container">

<pre class="src src-sql"><span style="color: #b5bd68;">CREATE</span> <span style="color: #b5bd68;">OR</span> REPLACE <span style="color: #b5bd68;">FUNCTION</span> <span style="color: #de935f;">si_same</span>(text, text)

        <span style="color: #b5bd68;">RETURNS</span> <span style="color: #81a2be;">int</span> <span style="color: #b5bd68;">AS</span>

$$

        <span style="color: #b5bd68;">BEGIN</span>

                <span style="color: #969896; font-style: italic;">-- ugly code for clarity</span>

                IF      normalize_si($1) &lt; normalize_si($2)

                <span style="color: #b5bd68;">THEN</span>

                        <span style="color: #b5bd68;">RETURN</span> -1;

                ELSIF   normalize_si($1) &gt; normalize_si($2)

                <span style="color: #b5bd68;">THEN</span>

                        <span style="color: #b5bd68;">RETURN</span> +1;

                <span style="color: #b5bd68;">ELSE</span>

                        <span style="color: #b5bd68;">RETURN</span> 0;

                <span style="color: #b5bd68;">END</span> IF;

        <span style="color: #b5bd68;">END</span>;

$$ <span style="color: #b5bd68;">LANGUAGE</span> <span style="color: #8abeb7;">'plpgsql'</span> IMMUTABLE;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6-4" class="outline-3">
<h3 id="sec-6-4">create the operator classes</h3>
<div class="outline-text-3" id="text-6-4">
<div class="org-src-container">

<pre class="src src-sql"><span style="color: #b5bd68;">CREATE</span> OPERATOR <span style="color: #b5bd68;">CLASS</span> sva_special_ops

<span style="color: #b5bd68;">FOR</span> <span style="color: #b5bd68;">TYPE</span> text <span style="color: #b5bd68;">USING</span> btree

<span style="color: #b5bd68;">AS</span>

OPERATOR        1       &lt;#  ,

OPERATOR        2       &lt;=# ,

OPERATOR        3       =  ,

OPERATOR        4       &gt;=# ,

OPERATOR        5       &gt;#  ,

<span style="color: #b5bd68;">FUNCTION</span>        1       si_same(text, text)

;
</pre>
</div>

<p>
we have to tell index, which operators to use when and which support
functions to use.
</p>

<div class="org-src-container">

<pre class="src src-sql"><span style="color: #b5bd68;">CREATE</span> INDEX idx_special <span style="color: #b5bd68;">ON</span> t_sva (sva sva_special_ops);

<span style="color: #b5bd68;">SET</span> enable_seqscan <span style="color: #b5bd68;">TO</span> <span style="color: #b5bd68;">off</span>;              <span style="color: #969896; font-style: italic;">-- to make sure that this work with just</span>

                                                           <span style="color: #969896; font-style: italic;">-- two rows</span>

explain <span style="color: #b5bd68;">SELECT</span> * <span style="color: #b5bd68;">FROM</span> t_sva <span style="color: #b5bd68;">WHERE</span> sva = <span style="color: #8abeb7;">'0000112276'</span>;

                                  QUERY PLAN                                  

<span style="color: #969896; font-style: italic;">-------------------------------------------------------------------------------</span>

 Index <span style="color: #b5bd68;">Only</span> Scan <span style="color: #b5bd68;">using</span> idx_special <span style="color: #b5bd68;">on</span> t_sva  (cost=0.13..8.14 <span style="color: #b5bd68;">rows</span>=1 width=32)

   Index Cond: (sva = <span style="color: #8abeb7;">'0000112276'</span>::text)

(2 <span style="color: #b5bd68;">rows</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6-5" class="outline-3">
<h3 id="sec-6-5">relative catalog info</h3>
<div class="outline-text-3" id="text-6-5">
<p>
tuplesort=# select * from pg_operator where oprnamespace=2200;
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="right" />

<col  class="right" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">oprname</th>
<th scope="col" class="right">oprnamespace</th>
<th scope="col" class="right">oprowner</th>
<th scope="col" class="left">oprkind</th>
<th scope="col" class="left">oprcanmerge</th>
<th scope="col" class="left">oprcanhash</th>
<th scope="col" class="right">oprleft</th>
<th scope="col" class="right">oprright</th>
<th scope="col" class="right">oprresult</th>
<th scope="col" class="right">oprcom</th>
<th scope="col" class="right">oprnegate</th>
<th scope="col" class="left">oprcode</th>
<th scope="col" class="left">oprrest</th>
<th scope="col" class="left">oprjoin</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">&lt;#</td>
<td class="right">2200</td>
<td class="right">10</td>
<td class="left">b</td>
<td class="left">f</td>
<td class="left">f</td>
<td class="right">25</td>
<td class="right">25</td>
<td class="right">16</td>
<td class="right">0</td>
<td class="right">0</td>
<td class="left">si_lt</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>

<tr>
<td class="left">&lt;=#</td>
<td class="right">2200</td>
<td class="right">10</td>
<td class="left">b</td>
<td class="left">f</td>
<td class="left">f</td>
<td class="right">25</td>
<td class="right">25</td>
<td class="right">16</td>
<td class="right">0</td>
<td class="right">0</td>
<td class="left">si_lt</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>

<tr>
<td class="left">&gt;=#</td>
<td class="right">2200</td>
<td class="right">10</td>
<td class="left">b</td>
<td class="left">f</td>
<td class="left">f</td>
<td class="right">25</td>
<td class="right">25</td>
<td class="right">16</td>
<td class="right">0</td>
<td class="right">0</td>
<td class="left">si_lt</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>

<tr>
<td class="left">&gt;#</td>
<td class="right">2200</td>
<td class="right">10</td>
<td class="left">b</td>
<td class="left">f</td>
<td class="left">f</td>
<td class="right">25</td>
<td class="right">25</td>
<td class="right">16</td>
<td class="right">0</td>
<td class="right">0</td>
<td class="left">si_lt</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
</tbody>
</table>

<p>
(4 rows)
</p>

<p>
tuplesort=# select * from pg_opfamily where opfnamespace=2200;
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="right" />

<col  class="left" />

<col  class="right" />

<col  class="right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="right">opfmethod</th>
<th scope="col" class="left">opfname</th>
<th scope="col" class="right">opfnamespace</th>
<th scope="col" class="right">opfowner</th>
</tr>
</thead>
<tbody>
<tr>
<td class="right">403</td>
<td class="left">sva_special_ops</td>
<td class="right">2200</td>
<td class="right">10</td>
</tr>
</tbody>
</table>

<p>
(1 row)
</p>

<p>
tuplesort=# select * from pg_opclass where opcnamespace=2200;
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="right" />

<col  class="left" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="left" />

<col  class="right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="right">opcmethod</th>
<th scope="col" class="left">opcname</th>
<th scope="col" class="right">opcnamespace</th>
<th scope="col" class="right">opcowner</th>
<th scope="col" class="right">opcfamily</th>
<th scope="col" class="right">opcintype</th>
<th scope="col" class="left">opcdefault</th>
<th scope="col" class="right">opckeytype</th>
</tr>
</thead>
<tbody>
<tr>
<td class="right">403</td>
<td class="left">sva_special_ops</td>
<td class="right">2200</td>
<td class="right">10</td>
<td class="right">41020</td>
<td class="right">25</td>
<td class="left">f</td>
<td class="right">0</td>
</tr>
</tbody>
</table>

<p>
(1 row)
</p>

<p>
tuplesort=# select * from pg_opfamily where oid=41020;
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="right" />

<col  class="left" />

<col  class="right" />

<col  class="right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="right">opfmethod</th>
<th scope="col" class="left">opfname</th>
<th scope="col" class="right">opfnamespace</th>
<th scope="col" class="right">opfowner</th>
</tr>
</thead>
<tbody>
<tr>
<td class="right">403</td>
<td class="left">sva_special_ops</td>
<td class="right">2200</td>
<td class="right">10</td>
</tr>
</tbody>
</table>

<p>
(1 row)
</p>
</div>
</div>

<div id="outline-container-sec-6-6" class="outline-3">
<h3 id="sec-6-6">pg_class</h3>
<div class="outline-text-3" id="text-6-6">
<p>
the pg_class system table contains one row for each table defined in
your database.
</p>
</div>
</div>
</div>


<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">system cache management</h2>
<div class="outline-text-2" id="text-7">
<p>
Every catalog cache must have a corresponding unique index on the
system table that it caches.[catcache.h] The extend explanation of it
is that every index in system table (ex., pg_class) has a
corresponding catalog cache represented by "struct catcache", every
row of the table that containing such a index has a corresponding tuple (presented by struct CatCtup) 
,which is stored in a double linked list, which is a element of
catcache' variable length array (called cc_bucket). Which double
linked list in cc_bucket is determined by hash value generated from
the row's contents and table's name. 
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #b5bd68;">typedef</span> <span style="color: #b5bd68;">struct</span> <span style="color: #81a2be;">catcache</span>
{
        <span style="color: #81a2be;">int</span>                     <span style="color: #f0c674;">id</span>;                             <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">cache identifier --- see syscache.h </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #b5bd68;">struct</span> <span style="color: #81a2be;">catcache</span> *<span style="color: #f0c674;">cc_next</span>;       <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">link to next catcache </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #b5bd68;">const</span> <span style="color: #81a2be;">char</span> *<span style="color: #f0c674;">cc_relname</span>;         <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">name of relation the tuples come from </span><span style="color: #969896; font-style: italic;">*/</span>
      ...

        TupleDesc       cc_tupdesc;             <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">tuple descriptor (copied from oreldesc) </span><span style="color: #969896; font-style: italic;">*/</span>
      ...
        <span style="color: #81a2be;">int</span>                     cc_nbuckets;    <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;"># of hash buckets in this cache </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">int</span>                     <span style="color: #f0c674;">cc_nkeys</span>;               <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;"># of keys (1..4) </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">int</span>                     <span style="color: #f0c674;">cc_key</span>[4];              <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">AttrNumber of each key </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">PGFunction</span>      <span style="color: #f0c674;">cc_hashfunc</span>[4]; <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">hash function to use for each key </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">ScanKeyData</span> <span style="color: #f0c674;">cc_skey</span>[4];         <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">precomputed key info for heap scans </span><span style="color: #969896; font-style: italic;">*/</span>

      ...
        Dllist          cc_bucket[1];   <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">hash buckets --- VARIABLE LENGTH ARRAY </span><span style="color: #969896; font-style: italic;">*/</span>
} <span style="color: #81a2be;">CatCache</span>;                                             <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">VARIABLE LENGTH STRUCT </span><span style="color: #969896; font-style: italic;">*/</span>
</pre>
</div>


<p>
syscache's type is catcache, which is a low-level catalog cache. Every
system catalog table (ie, pg_class) is one item of syscache, and each
one is first time initiated by cacheinfo, of course, syscache and
cacheinfo have the same amount of items.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #b5bd68;">struct</span> <span style="color: #81a2be;">cachedesc</span>
{
        <span style="color: #81a2be;">Oid</span>                     <span style="color: #f0c674;">reloid</span>;                 <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">OID of the relation being cached </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">Oid</span>                     <span style="color: #f0c674;">indoid</span>;                 <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">OID of index relation for this cache </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">int</span>                     <span style="color: #f0c674;">reloidattr</span>;             <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">attr number of rel OID reference, or 0 </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">int</span>                     <span style="color: #f0c674;">nkeys</span>;                  <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;"># of keys needed for cache lookup </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">int</span>                     <span style="color: #f0c674;">key</span>[4];                 <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">attribute numbers of key attrs </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">int</span>                     <span style="color: #f0c674;">nbuckets</span>;               <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">number of hash buckets for this cache </span><span style="color: #969896; font-style: italic;">*/</span>
};
</pre>
</div>

<p>
cacheinfo's type is cachedesc which defines a single syscache and contains all system catalog tables' index information, and
takes pg_class for examples,  
</p>
<div class="org-src-container">

<pre class="src src-c">{RelationRelationId,            <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">RELNAMENSP </span><span style="color: #969896; font-style: italic;">*/</span>
        ClassNameNspIndexId,
        ObjectIdAttributeNumber,
        2,
        {
                Anum_pg_class_relname,
                Anum_pg_class_relnamespace,
                0,
                0
        },
        1024
},
</pre>
</div>

<p>
ClassNameNspIndexId is defined in indexing.h:
</p>

<div class="org-src-container">

<pre class="src src-c">DECLARE_UNIQUE_INDEX(pg_class_relname_nsp_index, 2663, on pg_class <span style="color: #81a2be;">using</span> <span style="color: #f0c674;">btree</span>(<span style="color: #81a2be;">relname</span> <span style="color: #f0c674;">name_ops</span>, <span style="color: #81a2be;">relnamespace</span> <span style="color: #f0c674;">oid_ops</span>));
<span style="color: #b294bb;">#define</span> <span style="color: #f0c674;">ClassNameNspIndexId</span>  2663
</pre>
</div>

<p>
pg_class_relname_nsp_index is the table pg_class' index name, we can
verify it using command:
</p>

<div class="org-src-container">

<pre class="src src-sql">tuplesort=# \d pg_class;
      <span style="color: #b5bd68;">Table</span> "pg_catalog.pg_class"
     <span style="color: #b5bd68;">Column</span>     |   <span style="color: #b5bd68;">Type</span>    | Modifiers 
<span style="color: #969896; font-style: italic;">----------------+-----------+-----------</span>
 relname        | <span style="color: #b5bd68;">name</span>      | <span style="color: #b5bd68;">not</span> <span style="color: #b5bd68;">null</span>
 relnamespace   | oid       | <span style="color: #b5bd68;">not</span> <span style="color: #b5bd68;">null</span>

...

Indexes:
    "pg_class_oid_index" <span style="color: #b5bd68;">UNIQUE</span>, btree (oid)
    "pg_class_relname_nsp_index" <span style="color: #b5bd68;">UNIQUE</span>, btree (relname, relnamespace)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">composite variable declaration</h2>
<div class="outline-text-2" id="text-8">
<p>
A composite variable is one that corresponds to a complete row in a particular table. It has
fields that correspond to each column in the table. We can declare and use composite variables
in our stored procedures, either as rowtype or record.
</p>

<p>
To declare a composite variable, we use the rowtype declaration syntax
as follows:
</p>

<p>
name table%rowtype;
</p>

<p>
The result of this declaration will be a variable that itself has fields, one for each column in
the table on which it is based. Consider the following:
contact customer%rowtype;
</p>

<p>
This will create a variable called contact with fields corresponding to columns in the customer
table. To use the fields, we use the syntax variable.field. Here is an
example code fragment:
</p>

<div class="org-src-container">

<pre class="src src-sql"><span style="color: #b5bd68;">DECLARE</span>
contact customer%rowtype;
address text;
<span style="color: #b5bd68;">BEGIN</span>
contact.zipcode := <span style="color: #8abeb7;">'XY1 6ZZ'</span>;
contact.fname := <span style="color: #b5bd68;">NULL</span>;
address := contact.addressline || contact.town;
...
<span style="color: #b5bd68;">END</span>;
</pre>
</div>
</div>
</div>


<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9">catach cache for create a new user table</h2>
<div class="outline-text-2" id="text-9">
<p>
when create a new user table:
</p>
<div class="org-src-container">

<pre class="src src-sql"><span style="color: #b5bd68;">create</span> <span style="color: #b5bd68;">table</span> <span style="color: #de935f;">Reserves</span> (sid <span style="color: #81a2be;">integer</span>, bid <span style="color: #81a2be;">integer</span>,<span style="color: #b5bd68;">day</span> <span style="color: #81a2be;">date</span>,rname <span style="color: #81a2be;">char</span>(25));
</pre>
</div>

<p>
The user table's namespace oid is 2200, and corresponding name is
 "public", so the member of new talbe's corresponding relation(type: VarRange) has a value "public" from get\_namespace\_name():
</p>

<p>
ProcessUtility() -&gt; transformCreateStmt() -&gt; get\_namespace\_name() 
</p>


<p>
In PostgreSQL, creating a new table will define a new class, new type
and new attributes, so that it will add new row in pg_class, pg_type
and pg_attribute finished by calling AddNewRelationType(),
AddNewRelationTuple(pg_class_desc,&#x2026;) and AddNewAttributeTuples() in
heap_create_with_catalog(). At the same time, every system table has a
corresponding CatCache, so that calling get_relname_relid() and others to add a relative item in these
CatCache variable perspectively is necessary.
</p>

<p>
DefineRelation() -&gt; heap\_create\_with\_catalog()
</p>
</div>
</div>

<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10">data structure</h2>
<div class="outline-text-2" id="text-10">
<p>
VarRange, RangeTblEntry and RangeTblRef are used in parsing phase.
</p>

<ul class="org-ul">
<li>VarRange

<p>
RangeVar is used in From clauses and utility statements (such as
create table &#x2026;).
</p>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #969896; font-style: italic;">/*</span>
<span style="color: #969896; font-style: italic;"> * RangeVar - range variable, used in FROM clauses</span>
<span style="color: #969896; font-style: italic;"> *</span>
<span style="color: #969896; font-style: italic;"> * Also used to represent table names in utility statements; there, the alias</span>
<span style="color: #969896; font-style: italic;"> * field is not used, and inhOpt shows whether to apply the operation</span>
<span style="color: #969896; font-style: italic;"> * recursively to child tables.  In some contexts it is also useful to carry</span>
<span style="color: #969896; font-style: italic;"> * a TEMP table indication here.</span>
<span style="color: #969896; font-style: italic;"> </span><span style="color: #969896; font-style: italic;">*/</span>

<span style="color: #b5bd68;">typedef</span> <span style="color: #b5bd68;">struct</span> <span style="color: #81a2be;">RangeVar</span>
{
        <span style="color: #81a2be;">NodeTag</span>         <span style="color: #f0c674;">type</span>;
        <span style="color: #81a2be;">char</span>       *<span style="color: #f0c674;">catalogname</span>;        <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">the catalog (database) name, or NULL </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">char</span>       *<span style="color: #f0c674;">schemaname</span>;         <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">the schema name, or NULL </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">char</span>       *<span style="color: #f0c674;">relname</span>;            <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">the relation/sequence name </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">InhOption</span>       <span style="color: #f0c674;">inhOpt</span>;                 <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">expand rel by inheritance? recursively act</span>
<span style="color: #969896; font-style: italic;">                                                                 * on children? </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">bool</span>            <span style="color: #f0c674;">istemp</span>;                 <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">is this a temp relation/sequence? </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">Alias</span>      *<span style="color: #f0c674;">alias</span>;                      <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">table alias &amp; optional column aliases </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">int</span>                     <span style="color: #f0c674;">location</span>;               <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">token location, or -1 if unknown </span><span style="color: #969896; font-style: italic;">*/</span>
} <span style="color: #81a2be;">RangeVar</span>;
</pre>
</div>

<ul class="org-ul">
<li>RangeTblRef 
</li>
<li>RangeTblEntry
</li>

<li>ScanKey
A ScanKey represents the application of a comparison operator between
 a table or index column and a constant.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #b5bd68;">typedef</span> <span style="color: #b5bd68;">struct</span> <span style="color: #81a2be;">ScanKeyData</span>
{
        <span style="color: #81a2be;">int</span>                     <span style="color: #f0c674;">sk_flags</span>;               <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">flags, see below </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">AttrNumber</span>      <span style="color: #f0c674;">sk_attno</span>;               <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">table or index column number </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">StrategyNumber</span> <span style="color: #f0c674;">sk_strategy</span>; <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">operator strategy number </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">Oid</span>                     <span style="color: #f0c674;">sk_subtype</span>;             <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">strategy subtype </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">FmgrInfo</span>        <span style="color: #f0c674;">sk_func</span>;                <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">lookup info for function to call </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">Datum</span>           <span style="color: #f0c674;">sk_argument</span>;    <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">data to compare </span><span style="color: #969896; font-style: italic;">*/</span>
} <span style="color: #81a2be;">ScanKeyData</span>;

<span style="color: #b5bd68;">typedef</span> <span style="color: #81a2be;">ScanKeyData</span> *<span style="color: #81a2be;">ScanKey</span>;
</pre>
</div>

<p>
From ScanKeyData, sk_attno defines which column in a table or index,
sk_strategy indicates that we want to search the column's data &gt;, &gt;=,
=, &lt; or &lt;= sk_argument(in general, a constant), sk_func defines a
different function according to the different access
method Btree, Gist, Gin, or Hash included in pg_am, so that if
a specific AM is defined the corresponding function such as btgettuple
will be defined.
</p>

<ul class="org-ul">
<li>IndexScanDescData
</li>
</ul>

<div class="org-src-container">

<pre class="src src-s">typedef struct IndexScanDescData
{
	/* scan parameters */
	Relation        heapRelation;   /* heap relation descriptor, or NULL */
	Relation        indexRelation;  /* index relation descriptor */
	Snapshot        xs_snapshot;    /* snapshot to see */
	int                     numberOfKeys;   /* number of scan keys */
	ScanKey         keyData;                /* array of scan key descriptors */

	/* signaling to index AM about killing index tuples */
	bool            kill_prior_tuple;               /* last-returned tuple is dead */
	bool            ignore_killed_tuples;   /* do not return killed entries */

	/* index access method's private state */
	void       *opaque;                     /* access-method-specific info */
      ...
}
</pre>
</div>

<p>
heapRelation is a table, indexRelation is a index for a
specific column for the table, so that there are several different
indexRelations for one table. keyData is the original ScanKey, opaque
includes output ScanKey, and is corresponding to BTScanOpaque,
GinScanOpaque, and GistScanOpaque, HashScanOpaque.
</p>

<ul class="org-ul">
<li>HeapScanDescData
</li>
</ul>
<p>
If there is no index in a table, the search will use
HeapScanDescData. And HeapScanDescData includes many detailed info for
one talbe such as rs_nblocks.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #b5bd68;">typedef</span> <span style="color: #b5bd68;">struct</span> <span style="color: #81a2be;">HeapScanDescData</span>
{
        <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">scan parameters </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">Relation</span>        <span style="color: #f0c674;">rs_rd</span>;                  <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">heap relation descriptor </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">Snapshot</span>        <span style="color: #f0c674;">rs_snapshot</span>;    <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">snapshot to see </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">int</span>                     <span style="color: #f0c674;">rs_nkeys</span>;               <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">number of scan keys </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">ScanKey</span>         <span style="color: #f0c674;">rs_key</span>;                 <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">array of scan key descriptors </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">bool</span>            <span style="color: #f0c674;">rs_bitmapscan</span>;  <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">true if this is really a bitmap scan </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">bool</span>            <span style="color: #f0c674;">rs_pageatatime</span>; <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">verify visibility page-at-a-time? </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">bool</span>            <span style="color: #f0c674;">rs_allow_strat</span>; <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">allow or disallow use of access strategy </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">bool</span>            <span style="color: #f0c674;">rs_allow_sync</span>;  <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">allow or disallow use of syncscan </span><span style="color: #969896; font-style: italic;">*/</span>

        <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">state set up at initscan time </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">BlockNumber</span> <span style="color: #f0c674;">rs_nblocks</span>;         <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">number of blocks to scan </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">BlockNumber</span> <span style="color: #f0c674;">rs_startblock</span>;      <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">block # to start at </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">BufferAccessStrategy</span> <span style="color: #f0c674;">rs_strategy</span>;       <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">access strategy for reads </span><span style="color: #969896; font-style: italic;">*/</span>
        <span style="color: #81a2be;">bool</span>            <span style="color: #f0c674;">rs_syncscan</span>;    <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">report location to syncscan logic? </span><span style="color: #969896; font-style: italic;">*/</span>
</pre>
</div>
</div>
</div>



<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11">_bt_preprocess_keys() &#x2013; Preprocess scan keys</h2>
<div class="outline-text-2" id="text-11">
<p>
comments: One key purpose of this routine is to discover how many scan keys
must be satisfied to continue the scan. It also attempts to
eliminate redundant keys and detect contradictory keys.
</p>

<p>
what are contradictory keys? 
</p>

<p>
the following keys are contradictory keys:
</p>

<p>
key = 1 &amp;&amp; key &gt; 1 
</p>

<p>
the above two expressions do not exist in this function, they only
indicate that it is contradict if there exist two keys for one column of a table, one key's
operator is =, the other &gt;. How can we determine this case in
PostgreSQL? Key is represented by ScanKey variables, =/&gt; is
corressponding to operator strategy, which included in Scankey. If
the above cases exist, there must be two ScanKey variables, and their
sk_attno is the same vaule. In _bt_preprocess_keys(), The
different ScanKeys with the same sk_attno will be first stored in a
array xfrom[] in order of operator strategy definition BTLessStrategyNumber, BTLessEqualStrategyNumber,
BTEqualStrategyNumber, BTGreaterEqualStrategyNumber,
BTGreaterStrategyNumber, and then check whether they are contradict,
or redundant. 
</p>
<div class="org-src-container">

<pre class="src src-c">  inkeys = scan-&gt;keyData;
...
  cur = &amp;inkeys[0];
...
memset(xform, 0, <span style="color: #b5bd68;">sizeof</span>(xform));

  <span style="color: #b5bd68;">for</span> (i = 0;; cur++, i++)
{
  <span style="color: #b5bd68;">if</span> (... cur-&gt;sk_attno != attno){ <span style="color: #969896; font-style: italic;">//</span><span style="color: #969896; font-style: italic;">assert the same column</span>
       ...
       <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">Re-initialize for new attno </span><span style="color: #969896; font-style: italic;">*/</span>
       attno = cur-&gt;sk_attno;
       memset(xform, 0, <span style="color: #b5bd68;">sizeof</span>(xform));
  }
  j = cur-&gt;sk_strategy - 1;
    <span style="color: #b5bd68;">if</span> (xform[j] == <span style="color: #81a2be;">NULL</span>)
    {
          <span style="color: #969896; font-style: italic;">/* </span><span style="color: #969896; font-style: italic;">nope, so remember this scankey </span><span style="color: #969896; font-style: italic;">*/</span>
          xform[j] = cur;
   }

}
</pre>
</div>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #b294bb;">#define</span> <span style="color: #f0c674;">BTLessStrategyNumber</span>                    1
<span style="color: #b294bb;">#define</span> <span style="color: #f0c674;">BTLessEqualStrategyNumber</span>               2
<span style="color: #b294bb;">#define</span> <span style="color: #f0c674;">BTEqualStrategyNumber</span>                   3
<span style="color: #b294bb;">#define</span> <span style="color: #f0c674;">BTGreaterEqualStrategyNumber</span>    4
<span style="color: #b294bb;">#define</span> <span style="color: #f0c674;">BTGreaterStrategyNumber</span>                 5

<span style="color: #b294bb;">#define</span> <span style="color: #f0c674;">BTMaxStrategyNumber</span>                             5
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12">some useful calling path</h2>
<div class="outline-text-2" id="text-12">
<ul class="org-ul">
<li>btgettuple()-&gt;_bt_first()
</li>
<li>btbeginscan()-&gt;RelationGetIndexScan()-&gt;index_rescan()-&gt;FunctionCall2()-&gt;btgettuple()
</li>

<li>DefineRelation(CreateStmt *stmt, char relkind)-&gt;
heap_create_with_catalog(relname,&#x2026;)-&gt;get_relname_relid(const char
*relname, Oid relnamespace)-&gt;
</li>
</ul>
<p>
GetSysCacheOid(RELNAMENSP, PointerGetDatum(relname), ObjectIdGetDatum(relnamespace),
                                                  0, 0)
                                                  -&gt;SearchSysCache(cacheId,
                                                  key1, key2, key3,
                                                  key4) -&gt;
                                                  SearchCatCache(SysCache[cacheId],
                                                  key1, key2, key3,
                                                  key4) -&gt;
                                                  systable_beginscan(relation,&#x2026;) -&gt;
</p>
</div>
</div>

<div id="outline-container-sec-13" class="outline-2">
<h2 id="sec-13">simple path for one simple query</h2>
<div class="outline-text-2" id="text-13">
<p>
The whole course is mainy finished in exec_simple_query(const char
*query_string), 
</p>

<ol class="org-ol">
<li>produces parse tree list through:
</li>
</ol>
<div class="org-src-container">

<pre class="src src-c">parsetree_list = pg_parse_query(query_string);
</pre>
</div>

<ol class="org-ol">
<li>for every item, experiences analyze, rewrite and getting plan tree
</li>
</ol>
<div class="org-src-container">

<pre class="src src-c">querytree_list = pg_analyze_and_rewrite(parsetree, query_string,
                                                                                                <span style="color: #81a2be;">NULL</span>, 0);
plantree_list = pg_plan_queries(querytree_list, 0, <span style="color: #81a2be;">NULL</span>);
</pre>
</div>

<p>
4.execute plan tree
</p>
<div class="org-src-container">

<pre class="src src-c">portal = CreatePortal(<span style="color: #8abeb7;">""</span>, <span style="color: #81a2be;">true</span>, <span style="color: #81a2be;">true</span>);
PortalDefineQuery(portal,
                                  <span style="color: #81a2be;">NULL</span>,
                                  query_string,
                                  commandTag,
                                  plantree_list,
                                  <span style="color: #81a2be;">NULL</span>);

PortalStart(portal, <span style="color: #81a2be;">NULL</span>, InvalidSnapshot);

(<span style="color: #81a2be;">void</span>) PortalRun(portal,
                                 FETCH_ALL,
                                 isTopLevel,
                                 receiver,
                                 receiver,
                                 completionTag);
</pre>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p>DEFINITION NOT FOUND.</p></div>

<div class="footdef"><sup><a id="fn.2" name="fn.2" class="footnum" href="#fnr.2">2</a></sup> <p class="footpara">
<a href="http://www.cybertec.at/operator-classes-explained/">http://www.cybertec.at/operator-classes-explained/</a>
</p></div>


</div>
</div>
