---
category: computer science and enginneering
layout: post
title: "Reading Source Code for Initialization of Local Storm Cluster"
tags: ["Big data", "Storm"]
---

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">概括</h2>
<div class="outline-text-2" id="text-1">
<p>
对于local storm cluster，由用户调用testing/mk-local-storm-cluster来构建运行环境，因此对local storm cluster的初始化分析，从这里开始。
（当构建了运行环境以后，通过StormSubmitter/submitTopology用户定义的topology到storm集群）
</p>
<div class="org-src-container">

<pre class="src src-java">testing/mk-local-storm-cluster
</pre>
</div>

<p>
返回cluster-map，在cluster-map里包含了
</p>
<div class="org-src-container">

<pre class="src src-java">nimbus <span style="color: #81a2be;">nimbus</span>
<span style="color: #de935f;">port</span>-counter
daemon-conf
supervisors 
state (mk-distributed-cluster-state daemon-conf)
storm-cluster-state (mk-storm-cluster-state daemon-conf)
tmp-dirs (atom [nimbus-tmp zk-tmp])
zookeeper zk-handle
shared-context context
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">storm中的宏</h2>
<div class="outline-text-2" id="text-2">
<div class="org-src-container">

<pre class="src src-java">### util/fast-list-iter 

        (<span style="color: #81a2be;">defmacro</span> <span style="color: #f0c674;">fast</span>-list-iter [pairs &amp; body]
                (let [pairs (partition 2 pairs)
                        lists (map <span style="color: #81a2be;">second</span> <span style="color: #f0c674;">pairs</span>)
                        elems (map <span style="color: #81a2be;">first</span> <span style="color: #f0c674;">pairs</span>)
                        iters (map (fn [_] (gensym)) lists)
                        bindings (-&gt;&gt; (map (fn [i l] [i `(get-iterator ~l)]) iters lists) (<span style="color: #81a2be;">apply</span> <span style="color: #f0c674;">concat</span>))
                        tests (map (fn [i] `(iter-has-next? ~i)) iters)
                        assignments (-&gt;&gt; (map (fn [e i] [e `(iter-next ~i)]) elems iters) (<span style="color: #81a2be;">apply</span> <span style="color: #f0c674;">concat</span>))]
                        `(let [~<span style="color: #81a2be;">@bindings</span>]
                                (<span style="color: #b5bd68;">while</span> (and ~<span style="color: #81a2be;">@tests</span>)
                                        (let [~<span style="color: #81a2be;">@assignments</span>]
                                                ~<span style="color: #81a2be;">@body</span>
                                        )))))
</pre>
</div>


<ul class="org-ul">
<li>目的 
</li>
</ul>
<p>
对列表中的元素进行迭代，由用户提供元素操作。以worker/mk-transfer-fn中
扩展该宏为例：
</p>
<div class="org-src-container">

<pre class="src src-java">(fast-list-iter [[task tuple :as pair] tuple-batch]
(<span style="color: #b5bd68;">if</span> (local-tasks task)
    (.add local pair)
                        (.add remote pair)
                ))
</pre>
</div>
<p>
使用macroexpand的结果如下：
</p>
<div class="org-src-container">

<pre class="src src-java">(let* [G__1345 (backtype.storm.util/get-iterator tuple-batch)] 
        (clojure.core/<span style="color: #b5bd68;">while</span> (clojure.core/and (backtype.storm.util/iter-has-next? G__1345)) 
                (clojure.core/let [[task tuple :as pair]
        (backtype.storm.util/iter-next G__1345)] 
                (<span style="color: #b5bd68;">if</span> (local-tasks task) (.add local pair) (.add remote pair)))))
</pre>
</div>
<p>
为了更详细了解扩展细节，将所有中间变量打印出来：
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #81a2be;">pairs</span>:  (([task tuple :as pair] tuple-batch))
lists:  (tuple-batch)
elems:  ([task tuple :as pair])
iters:  (<span style="color: #81a2be;">G__1345</span>)
bindings:  (<span style="color: #81a2be;">G__1345</span> (backtype.storm.util/get-iterator tuple-batch))
tests:  ((backtype.storm.util/iter-has-next? G__1345))
assignments:  ([task tuple :as pair] (backtype.storm.util/iter-next G__1345))
</pre>
</div>
<p>
其中：
</p>

<ul class="org-ul">
<li>G__1345 通过 <i>gensym</i> 函数生成。
</li>
<li>tuple-batch 为 <b>ArrayList</b> 类型，因此使用 <b>get-iterator</b> 生成 <b>Iterator</b> ，然后使用 <b>util/iter-next</b> , 与java中直接使用 <b>for( elem: ArrayList)</b> 不同。举例：
<div class="org-src-container">

<pre class="src src-java">     user&gt; (<span style="color: #81a2be;">def</span> <span style="color: #f0c674;">al</span> (ArrayList. [[1 {1 5241700977694457705}], [3 {2 963084339025074184}], [2 {3 -6622099668460348678}]]))
     #<span style="color: #cc6666; font-weight: bold;">'</span><span style="color: #8abeb7;">user/al</span>
<span style="color: #8abeb7;">     user&gt; (let [al (get-iterator al)] (while (and (iter-has-next? al))</span>
<span style="color: #8abeb7;">                               (println (iter-next al))))</span>

<span style="color: #8abeb7;">[1 {1 5241700977694457705}]</span>
<span style="color: #8abeb7;">    [3 {2 963084339025074184}]</span>
<span style="color: #8abeb7;">    [2 {3 -6622099668460348678}]</span>
<span style="color: #8abeb7;">    nil</span>
<span style="color: #8abeb7;">    user&gt;</span>
</pre>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">spout的emit</h2>
<div class="outline-text-2" id="text-3">
<p>
用户spout类，与emit相关的代码，以 <b>storm.starter.spout.RandomSentenceSpout</b> 为例：
</p>
<div class="org-src-container">

<pre class="src src-java">    <span style="color: #b5bd68;">public</span> <span style="color: #b5bd68;">class</span> <span style="color: #81a2be;">RandomSentenceSpout</span> <span style="color: #b5bd68;">extends</span> <span style="color: #81a2be;">BaseRichSpout</span> {
            <span style="color: #81a2be;">SpoutOutputCollector</span> <span style="color: #f0c674;">_collector</span>;


<span style="color: #81a2be;">@Override</span>
<span style="color: #b5bd68;">public</span> <span style="color: #81a2be;">void</span> <span style="color: #de935f;">open</span>(<span style="color: #81a2be;">Map</span> <span style="color: #f0c674;">conf</span>, <span style="color: #81a2be;">TopologyContext</span> <span style="color: #f0c674;">context</span>, <span style="color: #81a2be;">SpoutOutputCollector</span> <span style="color: #f0c674;">collector</span>) {
    _collector = collector;
}

<span style="color: #81a2be;">@Override</span>
<span style="color: #b5bd68;">public</span> <span style="color: #81a2be;">void</span> <span style="color: #de935f;">nextTuple</span>() {
   ....
    _collector.emit(<span style="color: #b5bd68;">new</span> <span style="color: #81a2be;">Values</span>(sentence));
}
</pre>
</div>
<p>
在每个supervisor中，由worker进程，executor线程和task组成，对spout来说，会创建spout线程，由executor/mk-threads调用async-loop完成。
</p>

<p>
open()函数将在executor/mk-threads所产生的线程中被调用一次，完成一些初始化的工作，(a) 创建SpoutOutputCollector实例，open()函数完成之后，上面的__collector，就可以使用了。
</p>

<div class="org-src-container">

<pre class="src src-java">(<span style="color: #81a2be;">defmethod</span> <span style="color: #f0c674;">mk</span>-threads :spout [executor-data task-datas]
    ...
    (.open spout-obj
            storm-conf
                    (:user-context task-data)
                            (SpoutOutputCollector.
                                    (reify ISpoutOutputCollector
                                            (^List emit [<span style="color: #b5bd68;">this</span> ^String stream-id ^List tuple ^Object message-id]
                                                    (send-spout-msg stream-id tuple message-id nil)
</pre>
</div>
<p>
(b) 在调用open()和完成SpoutOutputCollector实例创建之前，实现了ISpoutOutputCollector接口，这里只给出通常需要的emit函数，它调用send-spout-msg来完成。
</p>

<p>
nextTuple()一旦被调用，spout消息就可以通过__collect.emit()发送出去了，而nextTuple()在哪里被调用呢：
</p>
<div class="org-src-container">

<pre class="src src-java">(<span style="color: #81a2be;">defmethod</span> <span style="color: #f0c674;">mk</span>-threads :spout [executor-data task-datas]
      ...
      (async-loop
        (fn []
               ...
                   (fn []
                           (fast-list-iter [^ISpout spout spouts] (.nextTuple
      spout)))
      ...
</pre>
</div>
<p>
通过对async-loop的函数的分析，可以知道，mk-threads中，传递给 async-loop的嵌套的(fn &#x2026; (fn &#x2026;)), 在内层的fn将会在每次线程被调度中执行，而内层的fn之前到外层fn定义之间的代码，只执行一次。  
</p>
</div>
</div>
