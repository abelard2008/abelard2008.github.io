---
layout: post
title: "linux system management"
tagline: "linux"
description: "linux system "
tags: ["tools"]
---
{% include JB/setup %}
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">将find找到的所有文件使用cp拷贝 到指定的目录</a></li>
<li><a href="#sec-2">配置 SSH 的无密码公钥认证的过程,需要如下操作</a></li>
<li><a href="#sec-3">建立 ssh 连接,只要將公鑰複製到 ~/.ssh/authorized\<sub>keys</sub> 就可以利用金鑰登入,而不需要建立密碼.如出现下面的错误？</a></li>
<li><a href="#sec-4">按照步骤配置完无密码ssh登录后，使用ssh登录，还是需要密码，怎么办？</a></li>
<li><a href="#sec-5">怎么让qemu的guest os通过host 的bridge上网以及让guest os 在host所在的局域网内 (主机操作系统为 Fedora 16 x86\<sub>64</sub>)</a></li>
<li><a href="#sec-6">使用vnc来显示qemu客户OS</a></li>
<li><a href="#sec-7">使用rsync命令从一台机器的内容同步到另一台机器时，会出现用户名和组名为数字</a></li>
<li><a href="#sec-8">为linux安装新的字体(环境为Fedora 12 x86<sub>64</sub>)</a></li>
<li><a href="#sec-9">架设dns服务器(环境为Fedora 12 x86<sub>64</sub>)</a></li>
<li><a href="#sec-10">查看已安装的perl模块</a></li>
<li><a href="#sec-11">列出目前在cpan中可用的模块</a></li>
<li><a href="#sec-12">安装perl模块(已安装MediaWikiDump为例)</a></li>
<li><a href="#sec-13">perl模块的卸载</a></li>
<li><a href="#sec-14">查看linux下某个端口被哪个程序占用,如想查看端口为5000被谁占用</a></li>
<li><a href="#sec-15">用yum安装rpm文件</a></li>
<li><a href="#sec-16">diff</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">将find找到的所有文件使用cp拷贝 到指定的目录</h2>
<div class="outline-text-2" id="text-1">
<p>
find ./openfiler/ -name "*.php" -exec cp {} ./NAS-storage/ \;
</p>

<p>
(1)-exec 参数后面跟的是 command 命令(如这里的cp)，
(2)'{}'  使用{}来表示文件名，也就是find前面处理过程中过滤出来的文件，用于command命令进行处理
(3);  command命令的终止，使用 ';' (分号）来判定，在后面必须有一个
';',分号前必须有空格；对于不同的系统，直接使用分号可能会有不
同的意义， 使用转义符 '\'在分号前明确说明，对于前面我们遇到
的问题，主要就是这个原因引起的！
2.RJ45
以下内容摘自wikipedia
</p>

<ol class="org-ol">
<li>差分传输是一种信号传输的技术，区别于传统的一根信号线一根地线的做法，差分传输在这两根线上都传输信号，这两个信号的振幅相等，相位相反。在这两根线上的传输的信号就是差分信号。信号接收端比较这两个电压的差值来判断发送端发送的是逻辑0还是逻辑1。在电路板上，差分走线必须是等长、等宽、紧密靠近、且在同一层面的两根线。
</li>

<li>8P8C，也称之为RJ45，是以太网使用双绞线连接时常用的连接器插头。 8P8C的意义是8个位置（Position）也就是8个凹槽，8个触点（Contact）也就是8个金属接点。
</li>
</ol>

<p>
连线颜色
</p>

<p>
在T568A中，与之相连的8根线分别定义为：绿白、绿；橙白、蓝；蓝白、橙；棕白、棕。在T568B中，与之相连的8根线分别定义为：橙白、橙；绿白、蓝；蓝白、绿；棕白、棕。其中橙白色和橙色组成一对差分传输线，绿白色和绿色组成一对差分传输线，蓝白色和蓝色组成一对差分传输线，棕白色和棕色组成一对差分传输线。T568A可以跟早期的USOC向下兼容，The United States National Communication Systems Federal Telecommunications Recommendations 不使用 T568B。
</p>

<p>
连线信号
</p>

<p>
在百兆以太网中，仅适用1、2、3、6四根线,差分信号传输方式，减少电磁干扰，其中1、2为TX(发送)（拧在一起），3、6为RX（接收）拧在一起。因此直连线就是两端同为EIA-568-A或者EIA-568-B，而以太网交叉线就是一端使用EIA-568-A，另一端使用EIA-568-B的连接方法。
</p>

<p>
在千兆以太网或者以太网供电中，全部的四对差分对都被使用。
</p>

<p>
T568B是RJ45端口连接双绞线时使用的一种线序，又称TIA/EIA-568-B线序: 橙白 橙 绿白 蓝 蓝白 绿 棕白 棕
</p>

<p>
T568A是RJ45端口连接双绞线时使用的一种线序，又称TIA/EIA-568-A线序：绿白 绿 橙白 蓝 蓝白 橙 棕白 棕
</p>
</div>
</div>


<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">配置 SSH 的无密码公钥认证的过程,需要如下操作</h2>
<div class="outline-text-2" id="text-2">
<p>
如下步骤都应该在本地主机(192.168.1.103)终端命令行上执行，不要在emacs的shell中执行
</p>

<div class="org-src-container">

<pre class="src src-sh">ssh-keygen -t rsa
cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys
</pre>
</div>

<p>
完成后，将公钥拷贝到要登录的远程主机(192.168.1.107)上：
</p>

<div class="org-src-container">

<pre class="src src-sh">[abelard@localhost ~]$ ssh-copy-id -i ~/.ssh/id_rsa.pub 192.168.1.107
</pre>
</div>

<p>
现在就可以无密码登录到远程主机上了，只是用户名必须是同一个，(网路上提议拷贝
时用borealis@192.168.1.107，但是试验没有成功。)
</p>
<div class="org-src-container">

<pre class="src src-sh">ssh -l abelard192.168.0.88
</pre>
</div>


<p>
如果这时候出现如下错误：
</p>
<pre class="example">
Agent admitted failure to sign using the key
</pre>
<p>
使用下面的方法：
</p>
<pre class="example">
ssh-add   ~/.ssh/id_rsa
</pre>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">建立 ssh 连接,只要將公鑰複製到 ~/.ssh/authorized\<sub>keys</sub> 就可以利用金鑰登入,而不需要建立密碼.如出现下面的错误？</h2>
<div class="outline-text-2" id="text-3">
<p>
Agent admitted failure to sign using the key
</p>

<p>
解決方式 使用 ssh-add 指令將私钥加進來 （根据个人的密匙命名不同更改 id\<sub>rsa）</sub>
</p>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">按照步骤配置完无密码ssh登录后，使用ssh登录，还是需要密码，怎么办？</h2>
<div class="outline-text-2" id="text-4">
<p>
很可能是因为authorized<sub>keys</sub> 文件的权限不对，使用下面的命令改为：
</p>
<pre class="example">
[abelard@dillon82 ~]$ chmod 600 .ssh/authorized_keys
</pre>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">怎么让qemu的guest os通过host 的bridge上网以及让guest os 在host所在的局域网内 (主机操作系统为 Fedora 16 x86\<sub>64</sub>)</h2>
<div class="outline-text-2" id="text-5">
<p>
说明：使用qemu的网桥模式，这样由qemu创建的guest os和
主机操作系统在同一个局域网内，即局域网内的所有主机都可以访问
该guest os。当然由于网桥可以在直接网桥方式和NAT/Masquerading
方式下工作，因此guest 和 host可以在同一个子网内（直接桥接方
式）也可以将guest隐藏起来，不与host在同一个子网，如下图
(<a href="http://en.gentoo-wiki.com/wiki/KVM#Networking_2">http://en.gentoo-wiki.com/wiki/KVM#Networking_2</a>)。
</p>

<p>
直接网桥模式:
</p>
<pre class="example">
                     host   
          +-----------------------+
          |                       |                             
	  |                       |        KVM GUEST1
          |  +-----------+        |     +--------------+ 
LAN ------+--+---  eth0  |   +----------+---  nic0     |      
          |  |     tap0 -----+    |     | 192.168.0.83 |      KVM GUEST2         
          |  |     tap1 -----+    |     +--------------+  +--------------+
          |  +-----------+   |    |                       |              |
          |          br0     +----+-----------------------+---- nic0     |
          |    192.168.0.88       |                       | 192.168.0.84 |
          +-----------------------+                       +--------------+
</pre>

<p>
NAT/Masquerading （网络地址转换/隐藏）网桥模式:
</p>
<pre class="example">
                     host   
          +-----------------------+
	  |                       |        KVM GUEST1
          |   192.168.1.88        |     +--------------+ 
LAN ------+-----  eth0            |     |              |
          |        ^              |     |              |
          |        |              |     |              |
          |  +-----------+   +----+-----+-----nic0     |   
          |  |     tap0 -----+    |     | 192.168.0.83 |      KVM GUEST2         
          |  |     tap1 -----+    |     +--------------+  +--------------+
          |  +-----------+   |    |                       |              |
          |          br0     +----+-----------------------+---- nic0     |
          |    192.168.0.88       |                       | 192.168.0.84 |
          +-----------------------+                       +--------------+
</pre>

<p>
第一步：安装和设置网桥（参考<a href="http://www.howtoforge.com/virtualization-with-kvm-on-a-fedora-14-server">Virtualization With KVM On A Fedora 14 Server</a>)
</p>

<ol class="org-ol">
<li>安装网桥和准备工作
</li>
</ol>
<pre class="example">
yum install bridge-utils
</pre>
<p>
为了让网桥顺利工作，需要关闭Network Manager，因为Network Manager好像不
支持网桥启动，可以先查看Network Manager是否启动，由于从Fedora14以后，
采用了<a href="http://freedesktop.org/wiki/Software/systemd">Systemd</a> 作为linux的系统和服务管理器，因此查看和关闭服务使用：
</p>
<pre class="example">
systemctl status networkmanager.service
systemctl stop networkmanager.service
</pre>
<p>
永久关闭该服务使用：
</p>
<pre class="example">
chkconfig NetworkManager off
chkconfig --levels 35 network on
</pre>
<p>
这时候重启网络，看看什么情况
</p>
<pre class="example">
systemctl restart network.service
</pre>
<ol class="org-ol">
<li>开始配置网卡和网桥
</li>
</ol>
<p>
/etc/sysconfig/network-scripts/ifcfg-p4p1的内容如下：重点需要关注的是
这里的NM<sub>CONTROLLED</sub>="no",而不是"yes"，就是说要关闭network manager，另
外就是加上了BRIDGE=br0。 (至于为什么是p4p1
不是eth0等，那是fedora新版本采用的名称)
</p>
<pre class="example">
DEVICE=p4p1
#BOOTPROTO=static
ONBOOT=yes
NM_CONTROLLED="no"
TYPE=Ethernet
DEFROUTE=yes
IPV4_FAILURE_FATAL=yes
IPV6INIT=no
NAME="System p4p1"
UUID=5dd47203-fffb-671a-4fd0-4cff98347a3b
HWADDR=00:25:64:8E:58:8C
PREFIX0=24
BRIDGE=br0
</pre>
<p>
还需要配置网桥，使用/etc/sysconfig/network-scripts/ifcfg-br0文件来完成，
可以看到该文件中配置了ip,gateway,dns等
</p>
<pre class="example">
DEVICE=br0
TYPE=Bridge
BOOTPROTO=static
ONBOOT=yes
IPADDR=192.168.0.88
NETMASK=255.255.255.0
GATEWAY=192.168.0.1
DNS1=192.168.0.1
DELAY=0
STP=off
</pre>
<p>
这时候重启网络
</p>
<pre class="example">
systemctl restart network.service
</pre>
<p>
正常的情况下应该看到如下信息：
</p>
<pre class="example">
[abelard@localhost ~]$ ifconfig
br0       Link encap:Ethernet  HWaddr 00:25:64:8E:58:8C  
          inet addr:192.168.0.88  Bcast:192.168.0.255  Mask:255.255.255.0
          inet6 addr: fe80::225:64ff:fe8e:588c/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:11611 errors:0 dropped:0 overruns:0 frame:0
          TX packets:10348 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:8935226 (8.5 MiB)  TX bytes:1445532 (1.3 MiB)

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:8 errors:0 dropped:0 overruns:0 frame:0
          TX packets:8 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:480 (480.0 b)  TX bytes:480 (480.0 b)

p4p1      Link encap:Ethernet  HWaddr 00:25:64:8E:58:8C  
          inet6 addr: fe80::225:64ff:fe8e:588c/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:12061 errors:0 dropped:0 overruns:0 frame:0
          TX packets:10384 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:9225251 (8.7 MiB)  TX bytes:1497788 (1.4 MiB)
          Interrupt:16
</pre>
<p>
可以使用nslookup www.google.com命令看看是否有问题！
</p>

<p>
第二步，创建tap设备
  有了网桥以后，先使用
</p>
<pre class="example">
[abelard@localhost ~]$ sudo lsmod | grep tun
</pre>
<p>
如果没有任何信息，使用
</p>
<pre class="example">
[abelard@localhost ~]$ sudo modprobe tun
[abelard@localhost ~]$ sudo lsmod | grep tun
tun                    14111  0
</pre>
<p>
如果还没有信息，就需要google一下，查找怎么yum一个tun模块。有信息的话，
就继续。
使用tunctl命令创建tap设备,并将tap设备添加到网桥br0中，
</p>
<pre class="example">
[abelard@localhost ~]$ sudo tunctl -b  -t tap0
[abelard@localhost ~]$ brctl addif br0 tap0
[abelard@localhost ~]$ sudo ifconfig tap0 up
[abelard@localhost ~]$ ifconfig
br0       Link encap:Ethernet  HWaddr 00:25:64:8E:58:8C  
          inet addr:192.168.0.88  Bcast:192.168.0.255  Mask:255.255.255.0
          inet6 addr: fe80::225:64ff:fe8e:588c/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:12165 errors:0 dropped:0 overruns:0 frame:0
          TX packets:10867 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:9116034 (8.6 MiB)  TX bytes:1529806 (1.4 MiB)

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:8 errors:0 dropped:0 overruns:0 frame:0
          TX packets:8 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:480 (480.0 b)  TX bytes:480 (480.0 b)

p4p1      Link encap:Ethernet  HWaddr 00:25:64:8E:58:8C  
          inet6 addr: fe80::225:64ff:fe8e:588c/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:12677 errors:0 dropped:0 overruns:0 frame:0
          TX packets:10903 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:9431240 (8.9 MiB)  TX bytes:1584348 (1.5 MiB)
          Interrupt:16 

tap0      Link encap:Ethernet  HWaddr 26:A1:36:5F:18:64  
          UP BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:500 
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
</pre>
<p>
这时候，网桥和tap设备都可以工作了，意味着qemu的网桥模式可以开始。
</p>

<p>
第三步 在qemu中使用网桥模式
</p>

<p>
使用过两种方式，
</p>

<p>
（1） 不设置启动脚本 
</p>
<pre class="example">
sudo qemu-kvm -hda CentOs5.7.img -net nic,macaddr=00:1d:92:ab:3f:78 -net tap,ifname=tap0,script=no,downscript=no -boot c
</pre>
<p>
这种方式，因为没有用到启动脚本(script=no,downscript=no),因此需要手动来使用上面的命令：
</p>
<pre class="example">
[abelard@localhost ~]$ brctl addif br0 tap0
[abelard@localhost ~]$ sudo ifconfig tap0 up
</pre>
<p>
（2） 设置qemu网络启动脚本/etc/qemu-ifup
</p>
<pre class="example">
#!/bin/sh
brctl addif br0 $1
ifconfig $1 up 0.0.0.0 promisc
</pre>
<p>
使用以下命令就可以启动guest os，并且可以在同一个子网中访问这个guest（192.168.0.81）
了，
</p>
<pre class="example">
sudo qemu-kvm -hda CentOs5.7.img -net nic,macaddr=00:1d:92:ab:3f:78 -net tap,ifname=tap0  -boot c
</pre>
<p>
或
</p>
<pre class="example">
sudo qemu-kvm -hda CentOs5.7.img -net nic,macaddr=00:00:00:00:00:00 -net tap,ifname=tap0 -boot c
</pre>
<p>
或
</p>
<pre class="example">
sudo qemu-kvm -hda CentOs5.7.img -net nic -net tap,ifname=tap0 -boot c
</pre>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">使用vnc来显示qemu客户OS</h2>
<div class="outline-text-2" id="text-6">
<ul class="org-ul">
<li>需要在主机操作系统(如Fedora 12)上安装vnc服务器和客户端软件，如
tigervnc,tigervnc-server
</li>
<li>使用带vnc参数启动qemu的客户操作系统
</li>
</ul>
<pre class="example">
[abelard@dillon vmware]$ sudo qemu-kvm -m 1G -hda Centos-mini.img -vnc 192.168.0.88:2  -boot c
</pre>
<p>
其中192.168.0.88为安装有vnc服务器软件的主机ip,‘:2’为端口号 ‘5900+2’
</p>
<ul class="org-ul">
<li>在主机os上启动vnc客户端来显示客户os
</li>
</ul>
<pre class="example">
[abelard@dillon ~]$ vncviewer 192.168.0.88:5902
</pre>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">使用rsync命令从一台机器的内容同步到另一台机器时，会出现用户名和组名为数字</h2>
<div class="outline-text-2" id="text-7">
<p>
假设：从192.168.0.109 同步到 192.168.0.0.88上，在109上的信息是：
-rw-r&#x2013;r&#x2013; 1 jiangshan jiangshan  2896 11月 22 08:11 README
同步到88上以后：
-rw-r&#x2013;r&#x2013; 1 1000 1000  2896 11月 22 08:11 README
</p>

<p>
显示为1000的原理是：在109上jiangshan的用户名和组ID为1000，在同步到88的
时候，先去/etc/passwd上查找，如果有1000的用户，则显示为其用户名，没有
的话就显示数字。
</p>

<p>
这是因为在88的机器上没有用户和组为jiangshan的，为了同步以后保持原样，
在88上使用如下命令创建用户名：
useradd jiangshan -u 1000
</p>

<p>
再同步后，88上就变成和109上一样了。
</p>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">为linux安装新的字体(环境为Fedora 12 x86<sub>64</sub>)</h2>
<div class="outline-text-2" id="text-8">
<p>
参考：<a href="http://blog.csdn.net/evanlinux/article/details/5507343">Fedora12下安装微软雅黑字体 </a>
</p>
<ol class="org-ol">
<li>先从windows下拷贝你需要的字体(目录为C:\windows\fonts),如
simsun.ttc,simhei.ttf,或或从网上下载需要的字体，如apple的MONACO.ttf
等宽字体， 将这些字体文件放在/usr/share/fonts/myFonts下，myFonts是
自己建的目录。
</li>
<li>执行如下命令
</li>
</ol>
<pre class="example">
cd /usr/share/fonts/myFonts
mkfontscale
mkfontdir
fc-cache -fv
</pre>
<ol class="org-ol">
<li>打开“系统”——“首选项”——“观感”——“外观”，在字体选项卡中就可以找到“宋
体，MONACO”等等了
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9">架设dns服务器(环境为Fedora 12 x86<sub>64</sub>)</h2>
<div class="outline-text-2" id="text-9">
<p>
参考 <a href="http://linux.vbird.org/linux_server/0350dns.php">第十九章、主機名稱控制者： DNS 伺服器</a>
</p>
<ol class="org-ol">
<li>先检查是否已安装相应的包
</li>
</ol>
<pre class="example">
[abelard@dillon ~]$ rpm -qa | grep '^bind'
bind-9.6.2-5.P2.fc12.x86_64
bind-libs-9.6.2-5.P2.fc12.x86_64
bind-utils-9.6.2-5.P2.fc12.x86_64
</pre>
<p>
2.配置 /etc/named.conf
</p>
<pre class="example">
options {
	//listen-on port 53 { any; };//any 代表全部接受
	//listen-on-v6 port 53 { ::1; };
	directory 	"/var/named";
	dump-file 	"/var/named/data/cache_dump.db";
        statistics-file "/var/named/data/named_stats.txt";
        memstatistics-file "/var/named/data/named_mem_stats.txt";
	allow-query     { any; };
	recursion yes;
	allow-transfer {any;}; //不许别人进行zone转移
};

logging {
        channel default_debug {
                file "data/named.run";
                severity dynamic;
        };
};

zone "." IN {
	type hint;
	file "named.ca";
};
zone "dillon.cloud" IN{ //新建的zone
	type master;
	file "named.dillon.cloud";
};

zone "0.168.192.in-addr.arpa" IN{ //新建的zone
  	type master;
	file "named.192.168.0";
};

include "/etc/named.rfc1912.zones";
</pre>

<p>
3.新建/var/named/named.dillon.cloud
</p>

<pre class="example">
$TTL 600
@	IN SOA master.dillon.cloud. cloud.www.dillon.cloud.(
	2011080401 3H 15M 1W 1D)
@	IN NS master.dillon.cloud.
master.dillon.cloud.	IN A 192.168.0.88
@	IN MX 10 www.dillon.cloud

www.dillon.cloud. IN A 192.168.0.88
</pre>

<p>
4.新建/var/named/named.192.168.0
</p>
<pre class="example">
$TTL 600
@ IN SOA master.dillon.cloud. cloud.www.dillon.cloud.(
	2011080401 3H 15M 1W 1D)
@ IN NS master.dillon.cloud.
88 IN PTR master.dillon.cloud.

88 IN PTR www.dillon.cloud
</pre>

<p>
5.测试
5.1 开启bind
</p>
<pre class="example">
[abelard@dillon ~]$ sudo /etc/init.d/named start
启动 named：                                               [确定]
</pre>
<p>
如果希望每次系统自动启动named,使用
</p>
<pre class="example">
[abelard@dillon ~]$ sudo chkconfig named on
</pre>
<p>
5.2 为了使用自己的dns，在/etc/resolv.conf添加dns服务器的ip
</p>
<pre class="example">
nameserver 192.168.0.88
</pre>
<p>
5.3 测试正反解
</p>
<pre class="example">
[abelard@dillon ~]$ nslookup 192.168.0.88
Server:		192.168.0.88
Address:	192.168.0.88#53

88.0.168.192.in-addr.arpa	name = master.dillon.cloud.
88.0.168.192.in-addr.arpa	name = www.dillon.cloud.0.168.192.in-addr.arpa.

[abelard@dillon ~]$ nslookup www.dillon.cloud
Server:		192.168.0.88
Address:	192.168.0.88#53

Name:	www.dillon.cloud
Address: 192.168.0.88
</pre>
<p>
5.4 启动后，出现错误怎么办
查看
</p>
<pre class="example">
[abelard@dillon ~]$ sudo tail -f -n 60 /var/log/messages
</pre>
</div>
</div>
<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10">查看已安装的perl模块</h2>
<div class="outline-text-2" id="text-10">
<pre class="example">
#!/usr/bin/perl 

use ExtUtils::Installed; 
my $instmod = ExtUtils::Installed-&gt;new(); 
foreach my $module ($instmod-&gt;modules()) { 


my $version = $instmod-&gt;version($module) || "???"; 
printf( "%-12s — %s\n", $module, $version);
#print "$module -- $version\n"; 
}
</pre>
</div>
</div>

<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11">列出目前在cpan中可用的模块</h2>
<div class="outline-text-2" id="text-11">
<p>
执行如下命令：
</p>
<pre class="example">
perl -MCPAN -e shell 
Terminal does not support AddHistory.

cpan shell -- CPAN exploration and modules installation (v1.9800)
Enter 'h' for help.

cpan[1]&gt; m
</pre>
</div>
</div>
<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12">安装perl模块(已安装MediaWikiDump为例)</h2>
<div class="outline-text-2" id="text-12">
<p>
有两种方式：手动和自动，自动的好处是那些依赖会自动安装，像Fedora的yum
一样，但是如果安装的过程中出错，没法知道错误的原因。
</p>

<ul class="org-ul">
<li>下载 Parse-MediaWikiDump-1.0.6.tar.gz 并解压，之后执行如下命令
</li>
</ul>

<pre class="example">
&gt;perl Makefile.PL
&gt;make
&gt;make test (optional)
&gt;make install
</pre>

<ul class="org-ul">
<li>自动安装
</li>
</ul>
<pre class="example">
#+begin_example
perl -MCPAN -e shell 
Terminal does not support AddHistory.

cpan shell -- CPAN exploration and modules installation (v1.9800)
Enter 'h' for help.

cpan[1]&gt; install Parse::MediaWikiDump
</pre>
</div>
</div>

<div id="outline-container-sec-13" class="outline-2">
<h2 id="sec-13">perl模块的卸载</h2>
<div class="outline-text-2" id="text-13">
<ul class="org-ul">
<li>删除相关的pm文件就可以了
</li>
</ul>
<p>
首先，使用下面的命令列出pm文件的可能位置，
</p>

<pre class="example">
$ perl -e 'print join "\n",@INC'
/usr/local/lib64/perl5/site_perl/5.10.0/x86_64-linux-thread-multi
/usr/local/lib/perl5/site_perl/5.10.0
/usr/lib64/perl5/vendor_perl/5.10.0/x86_64-linux-thread-multi
/usr/lib/perl5/vendor_perl/5.10.0
/usr/lib/perl5/vendor_perl
/usr/lib64/perl5/5.10.0/x86_64-linux-thread-multi
/usr/lib/perl5/5.10.0
/usr/lib/perl5/site_perl
</pre>
<p>
在这些位置里找到你关心的模块文件，比如version
</p>
<pre class="example">
# ls /usr/lib64/perl5/5.10.0/x86_64-linux-thread-multi/version* -l
-r--r--r-- 1 root root 6494 12月 10 2010 /usr/lib64/perl5/5.10.0/x86_64-linux-thread-multi/version.pm
-r--r--r-- 1 root root 9816 11月 28 2010 /usr/lib64/perl5/5.10.0/x86_64-linux-thread-multi/version.pod

/usr/lib64/perl5/5.10.0/x86_64-linux-thread-multi/version:
总用量 32
-r--r--r-- 1 root root 24861  3月 11 2010 Internals.pod
-r--r--r-- 1 root root   505 12月 10 2010 vxs.pm
</pre>
<p>
把这几个version相关的目录和文件删除就可以了
</p>
<ul class="org-ul">
<li></li>
</ul>
</div>
</div>
<div id="outline-container-sec-14" class="outline-2">
<h2 id="sec-14">查看linux下某个端口被哪个程序占用,如想查看端口为5000被谁占用</h2>
<div class="outline-text-2" id="text-14">
<p>
使用命令：
</p>
<pre class="example">
[abelard@dillon ~]$ netstat -tuanp | grep "5001"
</pre>
</div>
</div>
<div id="outline-container-sec-15" class="outline-2">
<h2 id="sec-15">用yum安装rpm文件</h2>
<div class="outline-text-2" id="text-15">
<p>
如果rpm文件如AdobeReader<sub>chs</sub>-8.1.7-1.i486.rpm，在Fedora 16
x86<sub>64的情况下，需要很多32位的依赖包，用rpm</sub> -ivh安装，会带
来很多痛苦，用yum安装，所有依赖包，它会自己帮你去找
</p>
<pre class="example">
sudo yum install Downloads/AdobeReader_chs-8.1.7-1.i486.rpm
</pre>
</div>
</div>
<div id="outline-container-sec-16" class="outline-2">
<h2 id="sec-16">diff</h2>
<div class="outline-text-2" id="text-16">
<p>
If you are only interested to see the files that differ, you may use:
</p>

<p>
diff -qr dir<sub>one</sub> dir<sub>two</sub> | sort
</p>

<p>
Option "q" will only show the files that differ but not the content that differ, and "sort" will arrange the output alphabetically.
</p>
</div>
</div>
